

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel - Gaming Tournament</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Dark Theme Variables --- */
        :root {
            --primary-bg: #0F172A; /* Slate 900 */
            --secondary-bg: #1E293B; /* Slate 800 */
            --card-bg: #1E293B; /* Slate 800 */
            --sidebar-bg: #111827; /* Gray 900 */
            --text-primary: #E2E8F0; /* Slate 200 */
            --text-secondary: #94A3B8; /* Slate 400 */
            --text-muted-custom: #64748B; /* Slate 500 - Improved visibility for muted text */
            --accent-color: #FACC15; /* Yellow 500 */
            --accent-gradient: linear-gradient(to right, #FACC15, #FBBF24);
            --primary-button-bg: #3B82F6; /* Blue 500 */
            --border-color: #334155; /* Slate 700 */
            --success-color: #10B981; /* Emerald 500 */
            --danger-color: #EF4444; /* Red 500 */
            --warning-color: #F59E0B; /* Amber 500 */
            --info-color: #60A5FA; /* Blue 400 */
            --link-color: #9CA3AF; /* Gray 400 */
            --link-hover-color: #E5E7EB; /* Gray 200 */
            --placeholder-bg: rgba(100, 116, 139, 0.15); /* Slate 500 with opacity */
        }
        body { background-color: var(--primary-bg); color: var(--text-primary); font-family: 'Poppins', sans-serif; padding-top: 60px; }
        .app-header { position: fixed; top: 0; left: 0; width: 100%; height: 60px; background-color: var(--secondary-bg); display: flex; align-items: center; justify-content: space-between; padding: 0 15px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); z-index: 1030; border-bottom: 1px solid var(--border-color);}
        .header-left { display: flex; align-items: center; gap: 10px;}
        .menu-toggle-btn { background: none; border: none; color: var(--text-primary); font-size: 1.5rem; padding: 0 5px; margin-left: -5px;}
        .header-logo { width: 35px; height: 35px; border-radius: 50%; background-color: #fff; object-fit: cover; border: 1px solid var(--accent-color);}
        .header-title { font-size: 1rem; font-weight: 600; line-height: 1.2;}
        .header-right { display: flex; align-items: center; gap: 15px;}
        .admin-email-header { font-size: 0.8rem; color: var(--text-secondary); display: none; }
        @media (min-width: 576px) { .admin-email-header { display: inline; } }
        .offcanvas-start { background-color: var(--sidebar-bg); color: var(--link-color); width: 260px !important; border-right: 1px solid var(--border-color);}
        .offcanvas-header { border-bottom: 1px solid var(--border-color); padding: 1rem 1.2rem;}
        .offcanvas-title h5 { color: var(--text-primary); margin-bottom: 0; font-size: 1.1rem; }
        .btn-close-white { filter: invert(1) grayscale(100%) brightness(200%);}
        .offcanvas-body { padding: 0; display: flex; flex-direction: column; height: calc(100% - 56px); }
        .offcanvas-body .nav { flex-grow: 1; overflow-y: auto; }
        .offcanvas-body .nav-link { color: var(--link-color); padding: 0.8rem 1.2rem; border-left: 3px solid transparent; font-size: 0.95rem;}
        .offcanvas-body .nav-link.active, .offcanvas-body .nav-link:hover { color: var(--link-hover-color); background-color: rgba(255, 255, 255, 0.05); border-left-color: var(--accent-color);}
        .offcanvas-body .nav-link i { margin-right: 12px; width: 20px; text-align: center; font-size: 1.1rem;}
        .offcanvas-logout-btn { margin: 1rem; border-top: 1px solid var(--border-color); padding-top: 1rem;}
        .main-content { padding: 20px; }
        .section { display: none; animation: fadeIn 0.5s; }
        .section.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .section-title { font-size: 1.25rem; font-weight: 600; margin-bottom: 20px; }
        .login-container { max-width: 400px; margin: 10vh auto; background-color: var(--secondary-bg); padding: 2rem; border-radius: 8px; border: 1px solid var(--border-color); box-shadow: 0 4px 12px rgba(0,0,0,0.2);}
        #adminLoader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 9999; display: none; }
        .spinner-border { color: var(--accent-color); }
        .card { background-color: var(--card-bg); border: 1px solid var(--border-color); color: var(--text-primary); margin-bottom: 1.5rem; }
        .card-title { color: var(--text-primary); }
        .table-responsive { overflow-x: auto; }
        .table { background-color: var(--card-bg); color: var(--text-primary); border-color: var(--border-color); margin-bottom: 0;}
        .table > :not(caption) > * > * { background-color: transparent !important; border-bottom-color: var(--border-color); }
        .table th { color: var(--text-secondary); font-weight: 500; white-space: nowrap; padding: 0.8rem 1rem;}
        .table td { vertical-align: middle; white-space: nowrap; padding: 0.7rem 1rem;}
        .table td .text-muted { color: var(--text-muted-custom) !important; }
        .table td small.text-muted { font-size: 0.85em; }
        .table-hover > tbody > tr:hover > * { background-color: rgba(255, 255, 255, 0.03) !important; color: var(--text-primary); }
        .action-buttons button, .action-buttons a { margin-right: 5px; margin-bottom: 5px; }
        .modal-content { background-color: var(--secondary-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        .modal-header { border-bottom-color: var(--border-color); }
        .modal-footer { border-top-color: var(--border-color); }
        .modal-body label { margin-bottom: 0.5rem; font-weight: 500; color: var(--text-secondary); }
        .form-control, .form-select { background-color: var(--primary-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        .form-control:focus, .form-select:focus { background-color: var(--primary-bg); color: var(--text-primary); border-color: var(--accent-color); box-shadow: 0 0 0 0.2rem rgba(250, 204, 21, 0.25); }
        .form-control::placeholder { color: var(--text-secondary); opacity: 0.7; }
        .form-control:disabled, .form-select:disabled { background-color: #2d3748; opacity: 0.7; }
        .form-control[type="file"] { background-color: var(--primary-bg); color: var(--text-secondary); border: 1px solid var(--border-color); }
        .imgbb-upload-status { display: none; margin-top: 5px; font-size: 0.85rem; color: var(--text-secondary);}
        .table img.preview-img { max-width: 60px; height: 40px; object-fit: cover; border-radius: 4px; cursor: pointer; border: 1px solid var(--border-color); }
        .text-bg-primary { background-color: #3B82F6 !important; }
        .text-bg-info { background-color: #0ea5e9 !important; }
        .text-bg-warning { background-color: #f59e0b !important; }
        .text-bg-success { background-color: #10b981 !important; }
        .text-bg-danger { background-color: #ef4444 !important; }
        .text-bg-secondary { background-color: #6b7280 !important; }
        .text-bg-dark { background-color: #374151 !important; }
        .nav-tabs .nav-link { color: var(--text-secondary); border-color: var(--border-color); border-bottom-color: transparent; margin-bottom: -1px;}
        .nav-tabs .nav-link.active { color: var(--accent-color); background-color: var(--card-bg); border-color: var(--border-color); border-bottom-color: var(--card-bg); font-weight: 600; }
        .nav-tabs { border-bottom-color: var(--border-color); }
        textarea.form-control { min-height: 120px; font-family: monospace; font-size: 0.9em; }
        .copy-btn { cursor: pointer; opacity: 0.6; transition: opacity 0.2s; }
        .copy-btn:hover { opacity: 1; }
        .status-badge { font-size: 0.8em; padding: 0.3em 0.6em; border-radius: 0.25rem; }
        .loading-placeholder td > div { background-color: var(--placeholder-bg); border-radius: 4px; min-height: 1.2em; animation: placeholder-glow 2s ease-in-out infinite; }
        @keyframes placeholder-glow { 0% { background-color: var(--placeholder-bg); } 50% { background-color: rgba(100, 116, 139, 0.2); } 100% { background-color: var(--placeholder-bg); } }
        .dash-card-icon { font-size: 1.8rem; opacity: 0.6; position: absolute; right: 15px; top: 50%; transform: translateY(-50%); }
        .card-body { position: relative; }
        .table td.wrap-text { white-space: normal; word-break: break-word; }
        .text-coin { color: #FFD700; }
    </style>
</head>
<body>

    <div id="adminLoader">
        <div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div>
    </div>

    <div id="auth-container" style="display: none;">
        <div id="admin-setup-section" style="display: none;">
            <div class="container login-container"> <div class="card shadow"> <div class="card-body p-4"> <h2 class="card-title text-center mb-4">Admin Account Setup</h2> <p class="text-muted text-center small mb-3">Create the primary admin account.</p> <form id="adminSetupForm"> <div class="mb-3"> <label for="setupEmail" class="form-label">Admin Email</label> <input type="email" class="form-control" id="setupEmail" required> </div> <div class="mb-3"> <label for="setupPassword" class="form-label">Admin Password (min 6 chars)</label> <input type="password" class="form-control" id="setupPassword" required minlength="6"> </div> <div id="adminSetupStatus" class="mt-3"></div> <div class="d-grid"> <button type="submit" class="btn btn-success">Create Admin Account</button> </div> </form> </div> </div> </div>
        </div>
        <div id="admin-login-section" style="display: none;">
            <div class="container login-container"> <div class="card shadow"> <div class="card-body p-4"> <h2 class="card-title text-center mb-4">Admin Login</h2> <form id="adminLoginForm"> <div class="mb-3"> <label for="adminEmail" class="form-label">Email</label> <input type="email" class="form-control" id="adminEmail" required> </div> <div class="mb-3"> <label for="adminPassword" class="form-label">Password</label> <input type="password" class="form-control" id="adminPassword" required> </div> <div id="adminLoginStatus" class="mt-3"></div> <div class="d-grid"> <button type="submit" class="btn btn-primary">Login</button> </div> </form> </div> </div> </div>
        </div>
    </div>

    <div id="admin-main-area" style="display:none;">
        <header class="app-header">
            <div class="header-left">
                <button class="menu-toggle-btn" type="button" data-bs-toggle="offcanvas" data-bs-target="#adminSidebar" aria-controls="adminSidebar">
                    <i class="bi bi-list"></i>
                </button>
                <img src="https://via.placeholder.com/35/1E293B/94A3B8?text=L" alt="Logo" class="header-logo" id="adminHeaderLogo" style="display:none;">
                <h1 class="header-title ms-1" id="adminPageTitle">Dashboard</h1>
            </div>
            <div class="header-right">
                <span class="admin-email-header" id="adminUserEmailShort">admin@example.com</span>
                <button class="btn btn-sm btn-outline-danger" id="adminLogoutBtnHeader"><i class="bi bi-box-arrow-right"></i> Logout</button>
            </div>
        </header>

        <div class="offcanvas offcanvas-start" tabindex="-1" id="adminSidebar" aria-labelledby="adminSidebarLabel">
            <div class="offcanvas-header">
                <h5 class="offcanvas-title" id="adminSidebarLabel">Admin Menu</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
            </div>
            <div class="offcanvas-body">
                <ul class="nav flex-column">
                     <li class="nav-item"> <a class="nav-link active" href="#" data-section="dashboard-section"><i class="bi bi-speedometer2"></i> Dashboard</a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="games-section"><i class="bi bi-controller"></i> Esport Games</a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="html-games-section"><i class="bi bi-joystick"></i> HTML Games</a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="promotions-section"><i class="bi bi-images"></i> Promotions</a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="tournaments-section"><i class="bi bi-trophy"></i> Tournaments</a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="tournament-results-section"><i class="bi bi-clipboard-check"></i> Tournament Results</a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="users-section"><i class="bi bi-people"></i> Users</a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="deposit-requests-section"><i class="bi bi-wallet2"></i> Deposit Requests <span class="badge bg-warning ms-1" id="pendingDepositCountBadge" style="display: none;">0</span></a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="withdrawals-section"><i class="bi bi-cash-coin"></i> Withdrawals <span class="badge bg-danger ms-1" id="pendingWithdrawalCountBadge" style="display: none;">0</span></a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="diamond-redemption-section"><i class="bi bi-gem"></i> Diamond Redemptions <span class="badge bg-info ms-1" id="pendingDiamondCountBadge" style="display: none;">0</span></a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="diamond-tiers-section"><i class="bi bi-tags"></i> Diamond Tiers</a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="tasks-section"><i class="bi bi-list-check"></i> Daily Tasks</a> </li>
                     <li class="nav-item"> <a class="nav-link" href="#" data-section="transactions-section"><i class="bi bi-receipt"></i> Transactions</a> </li>
                    <li class="nav-item"> <a class="nav-link" href="#" data-section="settings-section"><i class="bi bi-gear"></i> Settings</a> </li>
                </ul>
                <div class="mt-auto p-3 border-top border-secondary">
                     <button class="btn btn-warning btn-sm w-100 mb-2" id="addDemoDataBtn"><i class="bi bi-database-add"></i> Add Demo Data</button>
                     <small class="text-muted d-block text-center">Adds sample data if DB is empty.</small>
                </div>
            </div>
        </div>

        <main class="main-content" id="adminMainContent">
            <!-- Dashboard Section -->
            <section id="dashboard-section" class="section active">
                <h2>Dashboard Overview</h2>
                <div class="row">
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-primary shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Total Users</h5> <p class="card-text fs-3 fw-bold mb-0" id="statTotalUsers">--</p> <i class="bi bi-people-fill dash-card-icon"></i> </div> </div> </div>
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-info shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Active/Upcoming Tournaments</h5> <p class="card-text fs-3 fw-bold mb-0" id="statActiveTournaments">--</p> <i class="bi bi-trophy-fill dash-card-icon"></i> </div> </div> </div>
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-secondary shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Finished/Cancelled Tournaments</h5> <p class="card-text fs-3 fw-bold mb-0" id="statFinishedTournaments">--</p> <i class="bi bi-calendar-check-fill dash-card-icon"></i> </div> </div> </div>
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-warning shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Pending Deposits</h5> <p class="card-text fs-3 fw-bold mb-0" id="statPendingDeposits">--</p> <i class="bi bi-wallet-fill dash-card-icon"></i> </div> </div> </div>
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-danger shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Pending Withdrawals</h5> <p class="card-text fs-3 fw-bold mb-0" id="statPendingWithdrawals">--</p> <i class="bi bi-hourglass-split dash-card-icon"></i> </div> </div> </div>
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-success shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Completed Withdrawals</h5> <p class="card-text fs-3 fw-bold mb-0" id="statCompletedWithdrawals">--</p> <i class="bi bi-check-circle-fill dash-card-icon"></i> </div> </div> </div>
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-dark shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Rejected Withdrawals</h5> <p class="card-text fs-3 fw-bold mb-0" id="statRejectedWithdrawals">--</p> <i class="bi bi-x-octagon-fill dash-card-icon"></i> </div> </div> </div>
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-info shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Pending Diamond Redemptions</h5> <p class="card-text fs-3 fw-bold mb-0" id="statPendingDiamonds">--</p> <i class="bi bi-gem dash-card-icon"></i> </div> </div> </div>
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-secondary shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Total Esport Games</h5> <p class="card-text fs-3 fw-bold mb-0" id="statTotalGames">--</p> <i class="bi bi-controller dash-card-icon"></i> </div> </div> </div>
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-secondary shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Total HTML Games</h5> <p class="card-text fs-3 fw-bold mb-0" id="statTotalHtmlGames">--</p> <i class="bi bi-joystick dash-card-icon"></i> </div> </div> </div>
                    <div class="col-lg-3 col-md-6 mb-4"> <div class="card text-bg-secondary shadow-sm h-100"> <div class="card-body"> <h5 class="card-title">Total Promotions</h5> <p class="card-text fs-3 fw-bold mb-0" id="statTotalPromotions">--</p> <i class="bi bi-images dash-card-icon"></i> </div> </div> </div>
                </div>
                <div id="dashboardStatus"></div>
            </section>

            <!-- Esport Games Section -->
            <section id="games-section" class="section">
                <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2"> <h2>Manage Esport Games</h2> <button class="btn btn-success btn-sm" data-bs-toggle="modal" data-bs-target="#gameModal" id="addNewGameBtn"><i class="bi bi-plus-circle"></i> Add Esport Game</button> </div>
                 <div id="gamesStatus" class="mb-3"></div>
                <div class="table-responsive card"> <table class="table table-dark table-hover mb-0"> <thead> <tr><th>Image</th><th>Name</th><th>Game ID</th><th>Actions</th></tr> </thead> <tbody id="gamesTableBody"> <tr class="loading-placeholder"><td colspan="4"><div class="placeholder w-100 py-3"></div></td></tr> <tr class="loading-placeholder"><td colspan="4"><div class="placeholder w-100 py-3"></div></td></tr> </tbody> </table> </div>
            </section>
            
            <!-- HTML Games Section -->
            <section id="html-games-section" class="section">
                <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2"> <h2>Manage HTML Games</h2> <button class="btn btn-success btn-sm" data-bs-toggle="modal" data-bs-target="#htmlGameModal" id="addNewHtmlGameBtn"><i class="bi bi-plus-circle"></i> Add HTML Game</button> </div>
                 <div id="htmlGamesStatus" class="mb-3"></div>
                <div class="table-responsive card"> <table class="table table-dark table-hover mb-0"> <thead> <tr><th>Icon</th><th>Name</th><th>Cost (Coins)</th><th>Enabled</th><th>Actions</th></tr> </thead> <tbody id="htmlGamesTableBody"> <tr class="loading-placeholder"><td colspan="5"><div class="placeholder w-100 py-3"></div></td></tr></tbody> </table> </div>
            </section>

            <!-- Promotions Section -->
            <section id="promotions-section" class="section">
                <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2"> <h2>Manage Promotions</h2> <button class="btn btn-success btn-sm" data-bs-toggle="modal" data-bs-target="#promotionModal" id="addNewPromotionBtn"><i class="bi bi-plus-circle"></i> Add Promotion</button> </div>
                <div id="promotionsStatus" class="mb-3"></div>
                <div class="table-responsive card"> <table class="table table-dark table-hover mb-0"> <thead> <tr><th>Image</th><th>Link</th><th>Actions</th></tr> </thead> <tbody id="promotionsTableBody"> <tr class="loading-placeholder"><td colspan="3"><div class="placeholder w-100 py-3"></div></td></tr> </tbody> </table> </div>
             </section>

            <!-- Tournaments Section -->
            <section id="tournaments-section" class="section">
                 <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2"> <h2>Manage Tournaments</h2> <button class="btn btn-success btn-sm" data-bs-toggle="modal" data-bs-target="#addTournamentModal" id="addNewTournamentBtn"><i class="bi bi-plus-circle"></i> Add Tournament</button> </div>
                 <div id="tournamentsStatus" class="mb-3"></div>
                 <div class="table-responsive card"> <table class="table table-dark table-hover mb-0"> <thead> <tr><th>Name</th><th>Game</th><th>Fee (PKR/Coins)</th><th>Prize (PKR/Coins)</th><th>Start Time</th><th>Status</th><th>Players</th><th>Actions</th></tr> </thead> <tbody id="tournamentsTableBody"> <tr class="loading-placeholder"><td colspan="8"><div class="placeholder w-100 py-3"></div></td></tr> <tr class="loading-placeholder"><td colspan="8"><div class="placeholder w-100 py-3"></div></td></tr> </tbody> </table> </div>
            </section>

            <!-- Tournament Results Section -->
            <section id="tournament-results-section" class="section">
                <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
                    <h2>Tournament Results & Winnings</h2>
                </div>
                <div id="tournamentResultsStatus" class="mb-3"></div>
                <div class="table-responsive card">
                    <table class="table table-dark table-hover mb-0">
                        <thead>
                            <tr>
                                <th>Tournament Name</th>
                                <th>Game</th>
                                <th>Prize Pool (PKR/Coins)</th>
                                <th>Finished At</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="completedTournamentsTableBody">
                            <tr class="loading-placeholder"><td colspan="6"><div class="placeholder w-100 py-3"></div></td></tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Users Section -->
            <section id="users-section" class="section">
                <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
                    <h2>Manage Users</h2>
                    <div class="d-flex gap-2">
                        <input type="search" class="form-control form-control-sm" id="userSearchInput" placeholder="Search by Name, Email, App UID, or In-Game UID...">
                        <button class="btn btn-success btn-sm flex-shrink-0" data-bs-toggle="modal" data-bs-target="#addUserModal">
                            <i class="bi bi-person-plus-fill"></i> Add User
                        </button>
                    </div>
                </div>
                <div id="usersStatus" class="mb-3"></div>
                <div class="table-responsive card">
                    <table class="table table-dark table-hover mb-0">
                        <thead>
                            <tr>
                                <th>In-Game UID</th>
                                <th>Display Name</th>
                                <th>Email</th>
                                <th>PKR Balance</th>
                                <th>Coins</th>
                                <th>Referrals</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="usersTableBody">
                            <tr class="loading-placeholder"><td colspan="8"><div class="placeholder w-100 py-3"></div></td></tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Deposit Requests Section -->
            <section id="deposit-requests-section" class="section">
                <h2>Manage Deposit Requests</h2>
                <div id="depositRequestsStatus" class="mb-3"></div>
                 <div class="card">
                    <div class="card-header bg-secondary border-bottom border-dark"> <ul class="nav nav-tabs card-header-tabs" id="depositRequestTabs" role="tablist"> <li class="nav-item" role="presentation"><button class="nav-link active" id="pending-deposit-tab" data-bs-toggle="tab" data-bs-target="#pendingDepositsTabContent" type="button" role="tab">Pending</button></li> <li class="nav-item" role="presentation"><button class="nav-link" id="completed-deposit-tab" data-bs-toggle="tab" data-bs-target="#completedDepositsTabContent" type="button" role="tab">Completed</button></li> <li class="nav-item" role="presentation"><button class="nav-link" id="rejected-deposit-tab" data-bs-toggle="tab" data-bs-target="#rejectedDepositsTabContent" type="button" role="tab">Rejected</button></li> </ul> </div>
                    <div class="card-body tab-content p-0">
                        <div class="tab-pane fade show active" id="pendingDepositsTabContent" role="tabpanel">
                            <div class="table-responsive">
                                <table class="table table-dark table-hover mb-0">
                                    <thead><tr><th>Requested At</th><th>User</th><th>Amount (PKR)</th><th>Txn ID</th><th>Sender #</th><th>Sender Name</th><th>Actions</th></tr></thead>
                                    <tbody id="pending_verificationDepositsTableBody"> <tr class="loading-placeholder"><td colspan="7"><div class="placeholder w-100 py-3"></div></td></tr></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="tab-pane fade" id="completedDepositsTabContent" role="tabpanel">
                             <div class="table-responsive">
                                <table class="table table-dark table-hover mb-0">
                                    <thead><tr><th>Requested At</th><th>Processed At</th><th>User</th><th>Amount (PKR)</th><th>Txn ID</th><th>Sender #</th><th>Sender Name</th><th>Admin Note</th></tr></thead>
                                    <tbody id="completedDepositsTableBody"> <tr class="loading-placeholder"><td colspan="8"><div class="placeholder w-100 py-3"></div></td></tr></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="tab-pane fade" id="rejectedDepositsTabContent" role="tabpanel">
                             <div class="table-responsive">
                                <table class="table table-dark table-hover mb-0">
                                    <thead><tr><th>Requested At</th><th>Processed At</th><th>User</th><th>Amount (PKR)</th><th>Txn ID</th><th>Sender #</th><th>Sender Name</th><th>Reason</th></tr></thead>
                                    <tbody id="rejectedDepositsTableBody"> <tr class="loading-placeholder"><td colspan="8"><div class="placeholder w-100 py-3"></div></td></tr></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                 </div>
            </section>

            <!-- Withdrawals Section -->
            <section id="withdrawals-section" class="section">
                <h2>Manage Withdrawals</h2>
                 <div id="withdrawalsStatus" class="mb-3"></div>
                <div class="card">
                    <div class="card-header bg-secondary border-bottom border-dark"> <ul class="nav nav-tabs card-header-tabs" id="withdrawalTabs" role="tablist"> <li class="nav-item" role="presentation"><button class="nav-link active" id="pending-withdrawal-tab" data-bs-toggle="tab" data-bs-target="#pendingWithdrawalsTabContent" type="button" role="tab">Pending</button></li> <li class="nav-item" role="presentation"><button class="nav-link" id="completed-withdrawal-tab" data-bs-toggle="tab" data-bs-target="#completedWithdrawalsTabContent" type="button" role="tab">Completed</button></li> <li class="nav-item" role="presentation"><button class="nav-link" id="rejected-withdrawal-tab" data-bs-toggle="tab" data-bs-target="#rejectedWithdrawalsTabContent" type="button" role="tab">Rejected</button></li> </ul> </div>
                    <div class="card-body tab-content p-0">
                        <div class="tab-pane fade show active" id="pendingWithdrawalsTabContent" role="tabpanel">
                            <div class="table-responsive">
                                <table class="table table-dark table-hover mb-0">
                                    <thead><tr><th>Requested At</th><th>User</th><th>Amount (PKR)</th><th>Method</th><th>Account Info</th><th>Actions</th></tr></thead>
                                    <tbody id="pendingWithdrawalsTableBody"> <tr class="loading-placeholder"><td colspan="6"><div class="placeholder w-100 py-3"></div></td></tr> </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="tab-pane fade" id="completedWithdrawalsTabContent" role="tabpanel">
                            <div class="table-responsive">
                                <table class="table table-dark table-hover mb-0">
                                    <thead><tr><th>Requested At</th><th>Processed At</th><th>User</th><th>Amount (PKR)</th><th>Method</th><th>Account Info</th><th>Admin Note</th></tr></thead>
                                    <tbody id="completedWithdrawalsTableBody"> <tr class="loading-placeholder"><td colspan="7"><div class="placeholder w-100 py-3"></div></td></tr> </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="tab-pane fade" id="rejectedWithdrawalsTabContent" role="tabpanel">
                            <div class="table-responsive">
                                <table class="table table-dark table-hover mb-0">
                                    <thead><tr><th>Requested At</th><th>Processed At</th><th>User</th><th>Amount (PKR)</th><th>Method</th><th>Account Info</th><th>Reason</th></tr></thead>
                                    <tbody id="rejectedWithdrawalsTableBody"> <tr class="loading-placeholder"><td colspan="7"><div class="placeholder w-100 py-3"></div></td></tr></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                 </div>
            </section>
            
            <!-- Diamond Redemption Section -->
            <section id="diamond-redemption-section" class="section">
                <h2>Manage Diamond Redemptions</h2>
                <div id="diamondRedemptionStatus" class="mb-3"></div>
                <div class="card">
                    <div class="card-header bg-secondary border-bottom border-dark"> <ul class="nav nav-tabs card-header-tabs" id="diamondRedemptionTabs" role="tablist"> <li class="nav-item" role="presentation"><button class="nav-link active" id="pending-diamond-tab" data-bs-toggle="tab" data-bs-target="#pendingDiamondTabContent" type="button" role="tab">Pending</button></li> <li class="nav-item" role="presentation"><button class="nav-link" id="fulfilled-diamond-tab" data-bs-toggle="tab" data-bs-target="#fulfilledDiamondTabContent" type="button" role="tab">Fulfilled</button></li> <li class="nav-item" role="presentation"><button class="nav-link" id="rejected-diamond-tab" data-bs-toggle="tab" data-bs-target="#rejectedDiamondTabContent" type="button" role="tab">Rejected</button></li> </ul> </div>
                    <div class="card-body tab-content p-0">
                        <div class="tab-pane fade show active" id="pendingDiamondTabContent" role="tabpanel">
                            <div class="table-responsive">
                                <table class="table table-dark table-hover mb-0">
                                    <thead><tr><th>Requested At</th><th>User</th><th>In-Game UID</th><th>Diamonds</th><th>Coins Spent</th><th>Actions</th></tr></thead>
                                    <tbody id="pending_fulfillmentDiamondTableBody"> <tr class="loading-placeholder"><td colspan="6"><div class="placeholder w-100 py-3"></div></td></tr></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="tab-pane fade" id="fulfilledDiamondTabContent" role="tabpanel">
                             <div class="table-responsive">
                                <table class="table table-dark table-hover mb-0">
                                    <thead><tr><th>Requested At</th><th>Processed At</th><th>User</th><th>In-Game UID</th><th>Diamonds</th><th>Coins Spent</th><th>Admin Note</th></tr></thead>
                                    <tbody id="fulfilledDiamondTableBody"> <tr class="loading-placeholder"><td colspan="7"><div class="placeholder w-100 py-3"></div></td></tr></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="tab-pane fade" id="rejectedDiamondTabContent" role="tabpanel">
                             <div class="table-responsive">
                                <table class="table table-dark table-hover mb-0">
                                    <thead><tr><th>Requested At</th><th>Processed At</th><th>User</th><th>In-Game UID</th><th>Diamonds</th><th>Coins Spent</th><th>Reason</th></tr></thead>
                                    <tbody id="rejectedDiamondTableBody"> <tr class="loading-placeholder"><td colspan="7"><div class="placeholder w-100 py-3"></div></td></tr></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                 </div>
            </section>
            
            <!-- Diamond Tiers Section -->
            <section id="diamond-tiers-section" class="section">
                <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2"> <h2>Manage Diamond Tiers</h2> <button class="btn btn-success btn-sm" data-bs-toggle="modal" data-bs-target="#diamondTierModal" id="addNewDiamondTierBtn"><i class="bi bi-plus-circle"></i> Add New Tier</button> </div>
                <div id="diamondTiersStatus" class="mb-3"></div>
                <div class="table-responsive card"> <table class="table table-dark table-hover mb-0"> <thead> <tr><th>Title</th><th>Diamonds</th><th>Cost (Coins)</th><th>One-Time</th><th>Enabled</th><th>Actions</th></tr> </thead> <tbody id="diamondTiersTableBody"> <tr class="loading-placeholder"><td colspan="6"><div class="placeholder w-100 py-3"></div></td></tr></tbody> </table> </div>
            </section>
            
            <!-- Daily Tasks Section -->
            <section id="tasks-section" class="section">
                <div class="d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2"> <h2>Manage Daily Tasks</h2> <button class="btn btn-success btn-sm" data-bs-toggle="modal" data-bs-target="#taskModal" id="addNewTaskBtn"><i class="bi bi-plus-circle"></i> Add New Task</button> </div>
                <div id="tasksStatus" class="mb-3"></div>
                <div class="table-responsive card"> <table class="table table-dark table-hover mb-0"> <thead> <tr><th>Title</th><th>Reward (Coins)</th><th>Type</th><th>Goal</th><th>Enabled</th><th>Actions</th></tr> </thead> <tbody id="tasksTableBody"> <tr class="loading-placeholder"><td colspan="6"><div class="placeholder w-100 py-3"></div></td></tr></tbody> </table> </div>
            </section>

             <!-- Transactions Section -->
            <section id="transactions-section" class="section">
                <h2>User Transactions</h2>
                <div class="mb-3">
                    <label for="transactionUserSearchInput" class="form-label">Search by User UID, In-Game UID, Email or Name:</label>
                    <div class="input-group">
                        <input type="search" class="form-control form-control-sm" id="transactionUserSearchInput" placeholder="Enter User UID, In-Game UID, Email or Name...">
                        <button class="btn btn-outline-secondary btn-sm" type="button" id="fetchUserTransactionsBtn">Fetch Transactions</button>
                    </div>
                </div>
                <div id="transactionsStatus" class="mb-3"></div>
                <div class="table-responsive card">
                    <table class="table table-dark table-hover mb-0">
                        <thead><tr><th>Timestamp</th><th>Type</th><th>Amount (PKR)</th><th>Description</th><th>Details</th></tr></thead>
                        <tbody id="userTransactionsTableBody">
                            <tr><td colspan="5" class="text-center p-3 text-muted">Enter search term and click "Fetch" to view PKR transactions.</td></tr>
                        </tbody>
                    </table>
                </div>
                 <div class="table-responsive card mt-4">
                    <table class="table table-dark table-hover mb-0">
                        <thead><tr><th>Timestamp</th><th>Type</th><th>Amount (Coins)</th><th>Description</th><th>Details</th></tr></thead>
                        <tbody id="userCoinTransactionsTableBody">
                             <tr><td colspan="5" class="text-center p-3 text-muted">Coin transaction history for the selected user will appear here.</td></tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Settings Section -->
            <section id="settings-section" class="section card"> <div class="card-body"> <h2 class="card-title">App Settings</h2> <form id="appSettingsForm"> <div class="row"> <div class="col-md-6 mb-3"> <label for="settingLogoUrl" class="form-label">Logo URL</label> <input type="url" class="form-control" id="settingLogoUrl"> </div> <div class="col-md-6 mb-3"> <label for="settingAppName" class="form-label">App Name</label> <input type="text" class="form-control" id="settingAppName"> </div> <div class="col-md-6 mb-3"> <label for="settingMinWithdraw" class="form-label">Min Withdraw (PKR)</label> <input type="number" class="form-control" id="settingMinWithdraw" min="0" step="any"> </div> <div class="col-md-6 mb-3"> <label for="settingReferralBonus" class="form-label">Referral Bonus (PKR)</label> <input type="number" class="form-control" id="settingReferralBonus" min="0" step="any"> </div> <div class="col-md-6 mb-3"> <label for="settingNewUserBonus" class="form-label">New User Bonus (PKR)</label> <input type="number" class="form-control" id="settingNewUserBonus" min="0" step="any"> </div> <div class="col-md-6 mb-3"> <label for="settingNewUserGameCoins" class="form-label">New User Game Coins</label> <input type="number" class="form-control" id="settingNewUserGameCoins" min="0"> </div> <div class="col-12 mb-3"> <label for="settingSupportContact" class="form-label">Admin Support Contact</label> <input type="text" class="form-control" id="settingSupportContact"> </div> <div class="col-12 mb-3"> <label for="settingPaymentAccountDetails" class="form-label">EasyPaisa/JazzCash Account for Deposit</label> <input type="text" class="form-control" id="settingPaymentAccountDetails" placeholder="e.g., EasyPaisa: 03xxxxxxxxx (Name: John Doe)"> </div> 
            <div class="col-12 mb-3"><label for="settingDailyCheckinRewards" class="form-label">Daily Check-in Rewards (Coins)</label><input type="text" class="form-control" id="settingDailyCheckinRewards" placeholder="e.g., 5,5,10,5,5,15,25 (for 7 days)"><small class="text-muted">Comma-separated values for each consecutive day.</small></div>
            <div class="col-12 mb-3"> <label for="settingPolicyPrivacy" class="form-label">Privacy Policy</label> <textarea class="form-control" id="settingPolicyPrivacy" rows="5"></textarea> </div> <div class="col-12 mb-3"> <label for="settingPolicyTerms" class="form-label">Terms & Conditions</label> <textarea class="form-control" id="settingPolicyTerms" rows="5"></textarea> </div> <div class="col-12 mb-3"> <label for="settingPolicyRefund" class="form-label">Refund Policy</label> <textarea class="form-control" id="settingPolicyRefund" rows="5"></textarea> </div> <div class="col-12 mb-3"> <label for="settingPolicyFairPlay" class="form-label">Fair Play Policy</label> <textarea class="form-control" id="settingPolicyFairPlay" rows="5"></textarea> </div> </div> <button type="submit" class="btn btn-primary"><i class="bi bi-save"></i> Save Settings</button> <div id="settingsStatus" class="mt-3"></div> </form> </div> </section>
        </main>
    </div>

    <!-- Modals -->
    <div class="modal fade" id="gameModal" tabindex="-1"> <div class="modal-dialog"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title" id="gameModalTitle">Add New Esport Game</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <form id="gameForm"> <input type="hidden" id="gameEditId"> <div class="mb-3"> <label for="gameName" class="form-label">Game Name</label> <input type="text" class="form-control" id="gameName" required> </div> <div class="mb-3"> <label for="gameImageUrl" class="form-label">Image URL</label> <input type="url" class="form-control" id="gameImageUrl" required> <small class="text-muted">Direct image URL (e.g., from ImgBB).</small> </div> <div class="mb-3"> <label for="gameImageFile" class="form-label">Upload New Image (Optional - Overwrites URL)</label> <input class="form-control" type="file" id="gameImageFile" accept="image/*"> <div class="imgbb-upload-status mt-2"></div> </div> <div id="gameStatus" class="mt-2"></div></form> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button> <button type="button" class="btn btn-primary" id="saveGameBtn">Save Game</button> </div> </div> </div> </div>
    <div class="modal fade" id="htmlGameModal" tabindex="-1"> <div class="modal-dialog modal-lg"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title" id="htmlGameModalTitle">Add New HTML Game</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <form id="htmlGameForm"> <input type="hidden" id="htmlGameEditId"> <div class="row"> <div class="col-md-6 mb-3"> <label for="htmlGameName" class="form-label">Game Name</label> <input type="text" class="form-control" id="htmlGameName" required> </div> <div class="col-md-6 mb-3"> <label for="htmlGameIconUrl" class="form-label">Icon URL</label> <input type="url" class="form-control" id="htmlGameIconUrl" required> </div> <div class="col-12 mb-3"> <label for="htmlGameDescription" class="form-label">Description</label> <input type="text" class="form-control" id="htmlGameDescription"> </div> <div class="col-md-6 mb-3"> <label for="htmlGameGameUrl" class="form-label">Game URL (Method 1)</label> <input type="url" class="form-control" id="htmlGameGameUrl" placeholder="https://example.com/game/"> </div> <div class="col-md-6 mb-3"> <label for="htmlGameHtmlContent" class="form-label">HTML Content (Method 2)</label> <textarea class="form-control" id="htmlGameHtmlContent" rows="3" placeholder="Paste full HTML code here..."></textarea></div> <div class="col-md-4 mb-3"> <label for="htmlGameCost" class="form-label">Cost to Play (Coins)</label> <input type="number" class="form-control" id="htmlGameCost" min="0" value="0" required> </div> <div class="col-md-4 mb-3"> <label for="htmlGameOrder" class="form-label">Sort Order</label> <input type="number" class="form-control" id="htmlGameOrder" min="0" value="0"> </div> <div class="col-md-4 mb-3 d-flex align-items-end"> <div class="form-check form-switch"> <input class="form-check-input" type="checkbox" id="htmlGameEnabled" checked> <label class="form-check-label" for="htmlGameEnabled">Enabled</label> </div> </div> </div> <div id="htmlGameStatus" class="mt-2"></div></form> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button> <button type="button" class="btn btn-primary" id="saveHtmlGameBtn">Save HTML Game</button> </div> </div> </div> </div>
    <div class="modal fade" id="promotionModal" tabindex="-1"> <div class="modal-dialog"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title" id="promotionModalTitle">Add New Promotion</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <form id="promotionForm"> <input type="hidden" id="promotionEditId"> <div class="mb-3"> <label for="promoImageUrl" class="form-label">Image URL</label> <input type="url" class="form-control" id="promoImageUrl" required> <small class="text-muted">Direct image URL (e.g., from ImgBB).</small> </div> <div class="mb-3"> <label for="promoImageFile" class="form-label">Upload New Image (Optional - Overwrites URL)</label> <input class="form-control" type="file" id="promoImageFile" accept="image/*"> <div class="imgbb-upload-status mt-2"></div> </div> <div class="mb-3"> <label for="promoLink" class="form-label">Link (Optional)</label> <input type="url" class="form-control" id="promoLink"> </div> <div id="promotionStatus" class="mt-2"></div></form> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button> <button type="button" class="btn btn-primary" id="savePromotionBtn">Save Promotion</button> </div> </div> </div> </div>
    <div class="modal fade" id="addTournamentModal" tabindex="-1"> <div class="modal-dialog modal-lg"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title" id="tournamentModalTitle">Add New Tournament</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <form id="tournamentForm"> <input type="hidden" id="tournamentEditId"> <div class="row"> <div class="col-md-6 mb-3"> <label for="tournamentGame" class="form-label">Esport Game</label> <select class="form-select" id="tournamentGame" required></select> </div> <div class="col-md-6 mb-3"> <label for="tournamentName" class="form-label">Tournament Name</label> <input type="text" class="form-control" id="tournamentName" required> </div> <div class="col-md-6 mb-3"> <label for="tournamentStartTime" class="form-label">Start Date & Time</label> <input type="datetime-local" class="form-control" id="tournamentStartTime" required> </div> <div class="col-md-6 mb-3"> <label for="tournamentStatus" class="form-label">Status</label> <select class="form-select" id="tournamentStatus" required> <option value="upcoming">Upcoming</option> <option value="ongoing">Ongoing</option> <option value="completed">Completed</option> <option value="result">Result</option> <option value="cancelled">Cancelled</option> </select> </div> <div class="col-md-6 mb-3"> <label for="tournamentEntryFee" class="form-label">Entry Fee (PKR)</label> <input type="number" class="form-control" id="tournamentEntryFee" min="0" value="0" required step="any"> </div> <div class="col-md-6 mb-3"> <label for="tournamentEntryFeeCoins" class="form-label">Entry Fee (Coins)</label> <input type="number" class="form-control" id="tournamentEntryFeeCoins" min="0" value="0" required> </div> <div class="col-md-6 mb-3"> <label for="tournamentPrizePool" class="form-label">Total Prize Pool (PKR)</label> <input type="number" class="form-control" id="tournamentPrizePool" min="0" value="0" step="any"> </div> <div class="col-md-6 mb-3"> <label for="tournamentPrizePoolCoins" class="form-label">Total Prize Pool (Coins)</label> <input type="number" class="form-control" id="tournamentPrizePoolCoins" min="0" value="0"> </div> <div class="col-md-6 mb-3"> <label for="tournamentPerKill" class="form-label">Per Kill Prize (PKR)</label> <input type="number" class="form-control" id="tournamentPerKill" min="0" value="0" step="any"> </div> <div class="col-md-6 mb-3"> <label for="tournamentPerKillCoins" class="form-label">Per Kill Prize (Coins)</label> <input type="number" class="form-control" id="tournamentPerKillCoins" min="0" value="0"> </div> <div class="col-md-6 mb-3"> <label for="tournamentMaxPlayers" class="form-label">Max Players (0 for Unlimited)</label> <input type="number" class="form-control" id="tournamentMaxPlayers" min="0" value="0" required> </div> <div class="col-md-6 mb-3"> <label for="tournamentTags" class="form-label">Tags (comma-separated)</label> <input type="text" class="form-control" id="tournamentTags" placeholder="e.g., Solo, Erangel, TPP"> </div> <div class="col-12 mb-3"> <label for="tournamentDescription" class="form-label">Description / Rules</label> <textarea class="form-control" id="tournamentDescription" rows="4"></textarea> </div> <div class="col-md-6 mb-3"> <label for="tournamentRoomId" class="form-label">Room ID</label> <input type="text" class="form-control" id="tournamentRoomId"> </div> <div class="col-md-6 mb-3"> <label for="tournamentRoomPassword" class="form-label">Room Password</label> <input type="text" class="form-control" id="tournamentRoomPassword"> </div> <div class="form-check mb-3 ms-2"> <input class="form-check-input" type="checkbox" id="tournamentShowIdPass"> <label class="form-check-label" for="tournamentShowIdPass"> Show ID/Pass?</label> </div> </div> <div id="addTournamentStatus" class="mt-2"></div></form> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button> <button type="button" class="btn btn-primary" id="saveTournamentBtn">Save Tournament</button> </div> </div> </div> </div>
    <div class="modal fade" id="userModal" tabindex="-1"> <div class="modal-dialog modal-lg"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title" id="userModalTitle">User Details</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <div class="row"> <div class="col-md-6"> <h5>User Info</h5> <p><strong>App UID:</strong> <small id="userDetailUid" class="text-muted user-uid-copy"></small> <i class="bi bi-clipboard copy-btn ms-1" data-target-text="" title="Copy App UID"></i></p> <p><strong>In-Game UID:</strong> <strong id="userDetailGameUid" class="text-info">N/A</strong> <i class="bi bi-clipboard copy-btn ms-1" data-target-text="" title="Copy In-Game UID"></i></p> <p><strong>Email:</strong> <span id="userDetailEmail"></span></p> <p><strong>Email Status:</strong> <span id="userDetailVerificationStatus"></span></p> <p><strong>Name:</strong> <span id="userDetailName"></span></p> <p><strong>Created At:</strong> <span id="userDetailCreatedAt">N/A</span></p> <hr> <h5>Wallet</h5> <p>Total Balance: PKR <span id="userDetailBalance">0.00</span></p> <p>Winning Cash: PKR <span id="userDetailWinning">0.00</span></p> <p>Bonus Cash: PKR <span id="userDetailBonus">0.00</span></p> <p>Game Coins: <span class="text-coin"><i class="bi bi-coin"></i> <span id="userDetailCoins">0</span></span></p> <hr> <h5>Referral Info</h5> <p><strong>Referral Code:</strong> <span id="userDetailReferralCode" class="text-info">N/A</span> <i class="bi bi-clipboard copy-btn ms-1" data-target-text="" title="Copy Code"></i></p> <p><strong>Referred By:</strong> <span id="userDetailReferredBy">N/A</span></p> <p><strong>Users Referred:</strong> <span id="userDetailReferredCount">...</span></p> </div> <div class="col-md-6"> <h5>Update Balance (Caution!)</h5> <form id="updateBalanceForm"> <input type="hidden" id="editUserUid"> <div class="row"> <div class="col-md-6 mb-3"> <label for="balanceUpdateAmount" class="form-label">Amount (+/-)</label> <input type="number" step="any" class="form-control" id="balanceUpdateAmount" placeholder="e.g., 50 or -20" required> </div> <div class="col-md-6 mb-3"> <label for="balanceUpdateType" class="form-label">Balance Type</label> <select id="balanceUpdateType" class="form-select" required> <option value="">--Select--</option> <option value="balance">Total Balance (PKR)</option> <option value="winningCash">Winning Cash (PKR)</option> <option value="bonusCash">Bonus Cash (PKR)</option> <option value="gameCoins">Game Coins</option> </select> </div> </div> <div class="mb-3"> <label for="balanceUpdateReason" class="form-label">Reason</label> <input type="text" class="form-control" id="balanceUpdateReason" placeholder="Manual Deposit, Correction etc." required> </div> <button type="submit" class="btn btn-warning">Update Balance</button> <div id="balanceUpdateStatus" class="mt-2"></div> </form> <hr> <h5>Status & Actions</h5> <p>Current App Status: <span id="userDetailStatus" class="fw-bold"></span></p> <button class="btn btn-sm mb-2" id="userBlockBtn"></button> <button class="btn btn-sm btn-danger mb-2" id="userDeleteBtn"><i class="bi bi-trash"></i> Delete User (DB Only)</button> </div> </div> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button> </div> </div> </div> </div>
    <div class="modal fade" id="withdrawalActionModal" tabindex="-1"> <div class="modal-dialog"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title">Withdrawal Action</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <p><strong>Request ID:</strong> <small id="withdrawalDetailId" class="text-muted withdrawal-id-copy"></small> <i class="bi bi-clipboard copy-btn ms-1" data-target-text="" title="Copy Request ID"></i></p> <p><strong>User:</strong> <span id="withdrawalDetailUser"></span> (<small id="withdrawalDetailUserUid" class="text-muted withdrawal-user-uid-copy"></small> <i class="bi bi-clipboard copy-btn ms-1" data-target-text="" title="Copy User UID"></i>)</p> <p><strong>Amount:</strong> PKR <span id="withdrawalDetailAmount"></span></p> <p><strong>Method:</strong> <span id="withdrawalDetailMethod"></span></p> <hr> <div id="withdrawalRejectReasonDiv" style="display: none;" class="mb-3"> <label for="withdrawalRejectReason" class="form-label">Reason for Rejection</label> <textarea class="form-control" id="withdrawalRejectReason" rows="3" required></textarea> </div> <div id="withdrawalApproveNoteDiv" style="display: none;" class="mb-3"> <label for="withdrawalApproveNote" class="form-label">Admin Note / Txn ID (Optional)</label> <input type="text" class="form-control" id="withdrawalApproveNote" placeholder="e.g., Transaction ID"> </div> <div id="withdrawalActionStatus" class="mt-2"></div> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button> <button type="button" class="btn btn-danger" id="rejectWithdrawalBtn">Reject</button> <button type="button" class="btn btn-success" id="approveWithdrawalBtn">Approve</button> </div> </div> </div> </div>
    <div class="modal fade" id="diamondActionModal" tabindex="-1"> <div class="modal-dialog"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title">Diamond Redemption Action</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <p><strong>Request ID:</strong> <small id="diamondDetailId" class="text-muted"></small></p> <p><strong>User:</strong> <span id="diamondDetailUser"></span> (<small id="diamondDetailUserUid" class="text-muted"></small>)</p> <p><strong>In-Game UID:</strong> <strong class="text-info" id="diamondDetailGameUid"></strong></p> <p><strong>Diamonds:</strong> <span id="diamondDetailAmount"></span> <i class="bi bi-gem text-info"></i></p> <p><strong>Coins Spent:</strong> <span id="diamondDetailCoinsSpent"></span> <i class="bi bi-coin text-coin"></i></p><hr> <div id="diamondRejectReasonDiv" style="display: none;" class="mb-3"> <label for="diamondRejectReason" class="form-label">Reason for Rejection</label> <textarea class="form-control" id="diamondRejectReason" rows="3" required></textarea> </div> <div id="diamondApproveNoteDiv" style="display: none;" class="mb-3"> <label for="diamondApproveNote" class="form-label">Admin Note / Txn ID (Optional)</label> <input type="text" class="form-control" id="diamondApproveNote" placeholder="e.g., Fulfilled"> </div> <div id="diamondActionStatus" class="mt-2"></div> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button> <button type="button" class="btn btn-danger" id="rejectDiamondBtn">Reject</button> <button type="button" class="btn btn-success" id="approveDiamondBtn">Mark as Fulfilled</button> </div> </div> </div> </div>
    <div class="modal fade" id="addUserModal" tabindex="-1"> <div class="modal-dialog"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title">Add New User</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <form id="addUserForm"> <div class="mb-3"> <label for="newUserName" class="form-label">Display Name</label> <input type="text" class="form-control" id="newUserName" required> </div> <div class="mb-3"> <label for="newUserEmail" class="form-label">Email Address</label> <input type="email" class="form-control" id="newUserEmail" required> </div> <div class="mb-3"> <label for="newUserPassword" class="form-label">Password (min 6 chars)</label> <input type="password" class="form-control" id="newUserPassword" required minlength="6"> </div> <div class="mb-3"> <label for="newUserInitialBalance" class="form-label">Initial Balance (PKR)</label> <input type="number" step="any" class="form-control" id="newUserInitialBalance" value="0" min="0"> <small class="text-muted">This will be added to Total Balance.</small> </div> <div id="addUserStatus" class="mt-2"></div> </form> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button> <button type="button" class="btn btn-primary" id="saveNewUserBtn">Create User</button> </div> </div> </div> </div>
    <div class="modal fade" id="registeredPlayersModal" tabindex="-1"> <div class="modal-dialog modal-lg modal-dialog-scrollable"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title" id="registeredPlayersModalTitle">Registered Players</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <p>Tournament: <strong id="registeredPlayersTournamentName"></strong></p> <div id="registeredPlayersStatus" class="mb-2"></div> <div class="table-responsive"> <table class="table table-dark table-sm table-hover"> <thead> <tr><th>User UID</th><th>Name</th><th>Email</th><th>In-Game UID</th><th>Joined At</th></tr> </thead> <tbody id="registeredPlayersTableBody"> <tr><td colspan="5" class="text-center p-3"><div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div></td></tr> </tbody> </table> </div> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button> </div> </div> </div> </div>
    <div class="modal fade" id="depositActionModal" tabindex="-1"> <div class="modal-dialog"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title">Deposit Request Action</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <p><strong>Request ID:</strong> <small id="depositDetailId" class="text-muted"></small></p> <p><strong>User:</strong> <span id="depositDetailUser"></span> (<small id="depositDetailUserUid" class="text-muted"></small>)</p> <p><strong>Amount:</strong> PKR <span id="depositDetailAmount"></span></p> <p><strong>Transaction ID:</strong> <span id="depositDetailTxnId"></span></p> <p><strong>Sender Account:</strong> <span id="depositDetailSenderNumber"></span> (<span id="depositDetailSenderName"></span>)</p> <hr> <div id="depositRejectReasonDiv" style="display: none;" class="mb-3"> <label for="depositRejectReason" class="form-label">Reason for Rejection</label> <textarea class="form-control" id="depositRejectReason" rows="3" required></textarea> </div> <div id="depositApproveNoteDiv" style="display: none;" class="mb-3"> <label for="depositApproveNote" class="form-label">Admin Note (Optional)</label> <input type="text" class="form-control" id="depositApproveNote" placeholder="e.g., Verified"> </div>
                     <div id="depositActionStatus" class="mt-2"></div> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button> <button type="button" class="btn btn-danger" id="rejectDepositBtn">Reject</button> <button type="button" class="btn btn-success" id="approveDepositBtn">Approve</button> </div> </div> </div> </div>
    <!-- Tournament Winner Distribution Modal -->
    <div class="modal fade" id="tournamentWinnerModal" tabindex="-1">
        <div class="modal-dialog modal-xl modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="tournamentWinnerModalTitle">Distribute Winnings</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Tournament: <strong id="winnerModalTournamentName"></strong> (ID: <small id="winnerModalTournamentId" class="text-muted"></small>)</p>
                    <div id="tournamentWinnerStatus" class="mb-3"></div>
                    <form id="tournamentWinnerForm">
                        <div class="table-responsive">
                            <table class="table table-dark table-sm table-hover">
                                <thead>
                                    <tr>
                                        <th>#</th>
                                        <th>User (App)</th>
                                        <th>In-Game UID</th>
                                        <th>Winning (PKR)</th>
                                        <th>Winning (Coins)</th>
                                        <th>Status</th>
                                    </tr>
                                </thead>
                                <tbody id="tournamentWinnerPlayersTableBody">
                                    <!-- Player rows will be populated here by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                        <div class="mt-3">
                            <label for="tournamentResultNote" class="form-label">Overall Result Note (Optional)</label>
                            <textarea class="form-control" id="tournamentResultNote" rows="2" placeholder="e.g., Top 3 paid."></textarea>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="distributeWinningsBtn">Distribute Selected Winnings</button>
                    <button type="button" class="btn btn-success" id="finalizeTournamentResultsBtn">Finalize & Mark Results</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Diamond Tier Modal -->
    <div class="modal fade" id="diamondTierModal" tabindex="-1"> <div class="modal-dialog"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title" id="diamondTierModalTitle">Add New Tier</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <form id="diamondTierForm"> <input type="hidden" id="diamondTierEditId"> <div class="mb-3"> <label for="tierTitle" class="form-label">Title</label> <input type="text" class="form-control" id="tierTitle" placeholder="e.g., 100 Diamonds" required> </div> <div class="mb-3"> <label for="tierDescription" class="form-label">Description</label> <input type="text" class="form-control" id="tierDescription" placeholder="e.g., Standard 100 diamond pack."> </div> <div class="mb-3"> <label for="tierDiamonds" class="form-label">Diamonds Amount</label> <input type="number" class="form-control" id="tierDiamonds" required min="1"> </div> <div class="mb-3"> <label for="tierCost" class="form-label">Cost (Coins)</label> <input type="number" class="form-control" id="tierCost" required min="0"> </div> <div class="form-check form-switch mb-3"> <input class="form-check-input" type="checkbox" id="tierOneTime"> <label class="form-check-label" for="tierOneTime">One-Time Offer</label> </div> <div class="form-check form-switch mb-3"> <input class="form-check-input" type="checkbox" id="tierEnabled" checked> <label class="form-check-label" for="tierEnabled">Enabled</label> </div> <div id="diamondTierStatus" class="mt-2"></div> </form> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button> <button type="button" class="btn btn-primary" id="saveDiamondTierBtn">Save Tier</button> </div> </div> </div> </div>
    <!-- Task Modal -->
    <div class="modal fade" id="taskModal" tabindex="-1"> <div class="modal-dialog"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title" id="taskModalTitle">Add New Task</h5> <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button> </div> <div class="modal-body"> <form id="taskForm"> <input type="hidden" id="taskEditId"> <div class="mb-3"> <label for="taskTitle" class="form-label">Task Title</label> <input type="text" class="form-control" id="taskTitle" required> </div> <div class="mb-3"> <label for="taskDescription" class="form-label">Description</label> <input type="text" class="form-control" id="taskDescription"> </div> <div class="mb-3"> <label for="taskReward" class="form-label">Reward (Coins)</label> <input type="number" class="form-control" id="taskReward" required min="0"> </div> <div class="mb-3"> <label for="taskType" class="form-label">Task Type</label> <select class="form-select" id="taskType"> <option value="play_duration">Play Duration</option> <!-- Add other types if needed --> </select> </div> <div class="mb-3"> <label for="taskGoal" class="form-label">Goal</label> <input type="number" class="form-control" id="taskGoal" required min="1"> <small class="text-muted">e.g., 20 for 20 minutes of play time</small> </div> <div class="form-check form-switch mb-3"> <input class="form-check-input" type="checkbox" id="taskEnabled" checked> <label class="form-check-label" for="taskEnabled">Enabled</label> </div> <div id="taskStatus" class="mt-2"></div> </form> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button> <button type="button" class="btn btn-primary" id="saveTaskBtn">Save Task</button> </div> </div> </div> </div>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getDatabase, ref, get, set, update, push, query, orderByChild, equalTo, onValue, off, remove, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";
        // MODIFICATION: Added "sendEmailVerification"
        import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged, createUserWithEmailAndPassword, sendEmailVerification } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAIHe4zWYBILahVsKqNXMhuDYMbtUKeuS8",
            authDomain: "free-fire-tour-bee66.firebaseapp.com",
            databaseURL: "https://free-fire-tour-bee66-default-rtdb.firebaseio.com",
            projectId: "free-fire-tour-bee66",
            storageBucket: "free-fire-tour-bee66.appspot.com",
            messagingSenderId: "870298705820",
            appId: "1:870298705820:web:1b926022add17cd0643259",
            measurementId: "G-EDMPRWWZKG"
        };

        let app, db, auth;
        try {
            app = initializeApp(firebaseConfig);
            db = getDatabase(app);
            auth = getAuth(app);
            console.log("Admin Panel: Firebase Initialized.");
        }
        catch (error) {
            console.error("Admin Panel: Firebase initialization failed:", error);
            document.body.innerHTML = `<div class="alert alert-danger m-5"><strong>Critical Error:</strong> Could not connect to Firebase. Error: ${error.message}. Ensure your Firebase config is correct and the project is active.</div>`;
        }

        const getElement = (id) => document.getElementById(id);
        const querySel = (selector) => document.querySelector(selector);
        const querySelAll = (selector) => document.querySelectorAll(selector);
        const elements = {
             adminLoader: getElement('adminLoader'), authContainer: getElement('auth-container'), loginSection: getElement('admin-login-section'), setupSection: getElement('admin-setup-section'), mainArea: getElement('admin-main-area'), adminLoginForm: getElement('adminLoginForm'), adminEmailInput: getElement('adminEmail'), adminPasswordInput: getElement('adminPassword'), adminLoginStatus: getElement('adminLoginStatus'), adminSetupForm: getElement('adminSetupForm'), setupEmailInput: getElement('setupEmail'), setupPasswordInput: getElement('setupPassword'), setupStatus: getElement('adminSetupStatus'), adminUserEmailDisplay: getElement('adminUserEmailShort'), adminLogoutBtn: getElement('adminLogoutBtnHeader'), sidebar: getElement('adminSidebar'), sidebarLinks: querySelAll('#adminSidebar .nav-link'), sections: querySelAll('#adminMainContent .section'), adminPageTitle: getElement('adminPageTitle'), adminHeaderLogo: getElement('adminHeaderLogo'), dashboardSection: getElement('dashboard-section'), statTotalUsers: getElement('statTotalUsers'), statActiveTournaments: getElement('statActiveTournaments'), statPendingDeposits: getElement('statPendingDeposits'), statPendingWithdrawals: getElement('statPendingWithdrawals'), statCompletedWithdrawals: getElement('statCompletedWithdrawals'), statRejectedWithdrawals: getElement('statRejectedWithdrawals'), statTotalGames: getElement('statTotalGames'), statTotalHtmlGames: getElement('statTotalHtmlGames'), statPendingDiamonds: getElement('statPendingDiamonds'), statTotalPromotions: getElement('statTotalPromotions'), statFinishedTournaments: getElement('statFinishedTournaments'), dashboardStatus: getElement('dashboardStatus'), pendingDepositCountBadge: getElement('pendingDepositCountBadge'), pendingWithdrawalCountBadge: getElement('pendingWithdrawalCountBadge'), pendingDiamondCountBadge: getElement('pendingDiamondCountBadge'),
             gamesTableBody: getElement('gamesTableBody'), gameModalEl: getElement('gameModal'), gameModalTitle: getElement('gameModalTitle'), gameForm: getElement('gameForm'), gameEditId: getElement('gameEditId'), gameNameInput: getElement('gameName'), gameImageFileInput: getElement('gameImageFile'), gameImageUrlInput: getElement('gameImageUrl'), saveGameBtn: getElement('saveGameBtn'), gameStatus: getElement('gameStatus'), gamesStatus: getElement('gamesStatus'), addNewGameBtn: getElement('addNewGameBtn'),
             htmlGamesSection: getElement('html-games-section'), htmlGamesTableBody: getElement('htmlGamesTableBody'), htmlGameModalEl: getElement('htmlGameModal'), htmlGameModalTitle: getElement('htmlGameModalTitle'), htmlGameForm: getElement('htmlGameForm'), htmlGameEditId: getElement('htmlGameEditId'), htmlGameName: getElement('htmlGameName'), htmlGameIconUrl: getElement('htmlGameIconUrl'), htmlGameDescription: getElement('htmlGameDescription'), htmlGameGameUrl: getElement('htmlGameGameUrl'), htmlGameHtmlContent: getElement('htmlGameHtmlContent'), htmlGameCost: getElement('htmlGameCost'), htmlGameOrder: getElement('htmlGameOrder'), htmlGameEnabled: getElement('htmlGameEnabled'), saveHtmlGameBtn: getElement('saveHtmlGameBtn'), htmlGameStatus: getElement('htmlGameStatus'), htmlGamesStatus: getElement('htmlGamesStatus'),
             promotionsTableBody: getElement('promotionsTableBody'), promotionModalEl: getElement('promotionModal'), promotionModalTitle: getElement('promotionModalTitle'), promotionForm: getElement('promotionForm'), promotionEditId: getElement('promotionEditId'), promoImageFileInput: getElement('promoImageFile'), promoImageUrlInput: getElement('promoImageUrl'), promoLinkInput: getElement('promoLink'), savePromotionBtn: getElement('savePromotionBtn'), promotionStatus: getElement('promotionStatus'), promotionsStatus: getElement('promotionsStatus'), addNewPromotionBtn: getElement('addNewPromotionBtn'),
             tournamentsTableBody: getElement('tournamentsTableBody'), addTournamentModalEl: getElement('addTournamentModal'), tournamentForm: getElement('tournamentForm'), tournamentModalTitle: getElement('tournamentModalTitle'), tournamentEditId: getElement('tournamentEditId'), tournamentGameSelect: getElement('tournamentGame'), tournamentNameInput: getElement('tournamentName'), tournamentStartTimeInput: getElement('tournamentStartTime'), tournamentStatusSelect: getElement('tournamentStatus'), tournamentEntryFeeInput: getElement('tournamentEntryFee'), tournamentEntryFeeCoinsInput: getElement('tournamentEntryFeeCoins'), tournamentPrizePoolInput: getElement('tournamentPrizePool'), tournamentPrizePoolCoinsInput: getElement('tournamentPrizePoolCoins'), tournamentPerKillInput: getElement('tournamentPerKill'), tournamentPerKillCoinsInput: getElement('tournamentPerKillCoins'), tournamentMaxPlayersInput: getElement('tournamentMaxPlayers'), tournamentTagsInput: getElement('tournamentTags'), tournamentDescriptionInput: getElement('tournamentDescription'), tournamentRoomIdInput: getElement('tournamentRoomId'), tournamentRoomPasswordInput: getElement('tournamentRoomPassword'), tournamentShowIdPassCheckbox: getElement('tournamentShowIdPass'), saveTournamentBtn: getElement('saveTournamentBtn'), addNewTournamentBtn: getElement('addNewTournamentBtn'), addTournamentStatus: getElement('addTournamentStatus'), tournamentsStatus: getElement('tournamentsStatus'),
             usersSection: getElement('users-section'), usersTableBody: getElement('usersTableBody'), userSearchInput: getElement('userSearchInput'), userModalEl: getElement('userModal'), userModalTitle: getElement('userModalTitle'), userDetailUid: getElement('userDetailUid'), userDetailEmail: getElement('userDetailEmail'), userDetailName: getElement('userDetailName'), userDetailCreatedAt: getElement('userDetailCreatedAt'), userDetailBalance: getElement('userDetailBalance'), userDetailWinning: getElement('userDetailWinning'), userDetailBonus: getElement('userDetailBonus'), userDetailCoins: getElement('userDetailCoins'), userDetailReferralCode: getElement('userDetailReferralCode'), userDetailReferredBy: getElement('userDetailReferredBy'), userDetailReferredCount: getElement('userDetailReferredCount'), userDetailStatus: getElement('userDetailStatus'), updateBalanceForm: getElement('updateBalanceForm'), editUserUid: getElement('editUserUid'), balanceUpdateAmountInput: getElement('balanceUpdateAmount'), balanceUpdateTypeSelect: getElement('balanceUpdateType'), balanceUpdateReasonInput: getElement('balanceUpdateReason'), balanceUpdateStatus: getElement('balanceUpdateStatus'), userBlockBtn: getElement('userBlockBtn'), userDeleteBtn: getElement('userDeleteBtn'), addUserModalEl: getElement('addUserModal'), addUserForm: getElement('addUserForm'), newUserNameInput: getElement('newUserName'), newUserEmailInput: getElement('newUserEmail'), newUserPasswordInput: getElement('newUserPassword'), newUserInitialBalanceInput: getElement('newUserInitialBalance'), saveNewUserBtn: getElement('saveNewUserBtn'), addUserStatus: getElement('addUserStatus'), usersStatus: getElement('usersStatus'), userDetailGameUid: getElement('userDetailGameUid'), userDetailVerificationStatus: getElement('userDetailVerificationStatus'),
             depositRequestsSection: getElement('deposit-requests-section'), pending_verificationDepositsTableBody: getElement('pending_verificationDepositsTableBody'), completedDepositsTableBody: getElement('completedDepositsTableBody'), rejectedDepositsTableBody: getElement('rejectedDepositsTableBody'), depositActionModalEl: getElement('depositActionModal'), depositDetailId: getElement('depositDetailId'), depositDetailUser: getElement('depositDetailUser'), depositDetailUserUid: getElement('depositDetailUserUid'), depositDetailAmount: getElement('depositDetailAmount'), depositDetailTxnId: getElement('depositDetailTxnId'), depositDetailSenderNumber: getElement('depositDetailSenderNumber'), depositDetailSenderName: getElement('depositDetailSenderName'), depositRejectReasonDiv: getElement('depositRejectReasonDiv'), depositRejectReasonInput: getElement('depositRejectReason'), depositApproveNoteDiv: getElement('depositApproveNoteDiv'), depositApproveNoteInput: getElement('depositApproveNote'), depositActionStatus: getElement('depositActionStatus'), rejectDepositBtn: getElement('rejectDepositBtn'), approveDepositBtn: getElement('approveDepositBtn'), depositRequestsStatus: getElement('depositRequestsStatus'),
             pendingWithdrawalsTableBody: getElement('pendingWithdrawalsTableBody'), completedWithdrawalsTableBody: getElement('completedWithdrawalsTableBody'), rejectedWithdrawalsTableBody: getElement('rejectedWithdrawalsTableBody'), withdrawalActionModalEl: getElement('withdrawalActionModal'), withdrawalDetailId: getElement('withdrawalDetailId'), withdrawalDetailUser: getElement('withdrawalDetailUser'), withdrawalDetailUserUid: getElement('withdrawalDetailUserUid'), withdrawalDetailAmount: getElement('withdrawalDetailAmount'), withdrawalDetailMethod: getElement('withdrawalDetailMethod'), withdrawalRejectReasonDiv: getElement('withdrawalRejectReasonDiv'), withdrawalRejectReasonInput: getElement('withdrawalRejectReason'), withdrawalApproveNoteDiv: getElement('withdrawalApproveNoteDiv'), withdrawalApproveNoteInput: getElement('withdrawalApproveNote'), withdrawalActionStatus: getElement('withdrawalActionStatus'), rejectWithdrawalBtn: getElement('rejectWithdrawalBtn'), approveWithdrawalBtn: getElement('approveWithdrawalBtn'), withdrawalsStatus: getElement('withdrawalsStatus'),
             diamondRedemptionSection: getElement('diamond-redemption-section'), pending_fulfillmentDiamondTableBody: getElement('pending_fulfillmentDiamondTableBody'), fulfilledDiamondTableBody: getElement('fulfilledDiamondTableBody'), rejectedDiamondTableBody: getElement('rejectedDiamondTableBody'), diamondActionModalEl: getElement('diamondActionModal'), diamondDetailId: getElement('diamondDetailId'), diamondDetailUser: getElement('diamondDetailUser'), diamondDetailUserUid: getElement('diamondDetailUserUid'), diamondDetailGameUid: getElement('diamondDetailGameUid'), diamondDetailAmount: getElement('diamondDetailAmount'), diamondDetailCoinsSpent: getElement('diamondDetailCoinsSpent'), diamondRejectReasonDiv: getElement('diamondRejectReasonDiv'), diamondRejectReasonInput: getElement('diamondRejectReason'), diamondApproveNoteDiv: getElement('diamondApproveNoteDiv'), diamondApproveNoteInput: getElement('diamondApproveNote'), diamondActionStatus: getElement('diamondActionStatus'), rejectDiamondBtn: getElement('rejectDiamondBtn'), approveDiamondBtn: getElement('approveDiamondBtn'), diamondRedemptionStatus: getElement('diamondRedemptionStatus'),
             diamondTiersSection: getElement('diamond-tiers-section'), diamondTiersTableBody: getElement('diamondTiersTableBody'), diamondTierModalEl: getElement('diamondTierModal'), diamondTierModalTitle: getElement('diamondTierModalTitle'), diamondTierForm: getElement('diamondTierForm'), diamondTierEditId: getElement('diamondTierEditId'), tierTitle: getElement('tierTitle'), tierDescription: getElement('tierDescription'), tierDiamonds: getElement('tierDiamonds'), tierCost: getElement('tierCost'), tierOneTime: getElement('tierOneTime'), tierEnabled: getElement('tierEnabled'), saveDiamondTierBtn: getElement('saveDiamondTierBtn'), diamondTierStatus: getElement('diamondTierStatus'), diamondTiersStatus: getElement('diamondTiersStatus'),
             tasksSection: getElement('tasks-section'), tasksTableBody: getElement('tasksTableBody'), taskModalEl: getElement('taskModal'), taskModalTitle: getElement('taskModalTitle'), taskForm: getElement('taskForm'), taskEditId: getElement('taskEditId'), taskTitle: getElement('taskTitle'), taskDescription: getElement('taskDescription'), taskReward: getElement('taskReward'), taskType: getElement('taskType'), taskGoal: getElement('taskGoal'), taskEnabled: getElement('taskEnabled'), saveTaskBtn: getElement('saveTaskBtn'), taskStatus: getElement('taskStatus'), tasksStatus: getElement('tasksStatus'),
             registeredPlayersModalEl: getElement('registeredPlayersModal'), registeredPlayersModalTitle: getElement('registeredPlayersModalTitle'), registeredPlayersTournamentName: getElement('registeredPlayersTournamentName'), registeredPlayersTableBody: getElement('registeredPlayersTableBody'), registeredPlayersStatus: getElement('registeredPlayersStatus'),
             settingsSection: getElement('settings-section'), appSettingsForm: getElement('appSettingsForm'), settingLogoUrlInput: getElement('settingLogoUrl'), settingAppNameInput: getElement('settingAppName'), settingMinWithdrawInput: getElement('settingMinWithdraw'), settingReferralBonusInput: getElement('settingReferralBonus'), settingNewUserBonusInput: getElement('settingNewUserBonus'), settingNewUserGameCoinsInput: getElement('settingNewUserGameCoins'), settingDailyCheckinRewardsInput: getElement('settingDailyCheckinRewards'), settingSupportContactInput: getElement('settingSupportContact'), settingPaymentAccountDetailsInput: getElement('settingPaymentAccountDetails'), settingPolicyPrivacyInput: getElement('settingPolicyPrivacy'), settingPolicyTermsInput: getElement('settingPolicyTerms'), settingPolicyRefundInput: getElement('settingPolicyRefund'), settingPolicyFairPlayInput: getElement('settingPolicyFairPlay'), settingsStatus: getElement('settingsStatus'),
             addDemoDataBtn: getElement('addDemoDataBtn'),
             transactionsSection: getElement('transactions-section'), transactionUserSearchInput: getElement('transactionUserSearchInput'), fetchUserTransactionsBtn: getElement('fetchUserTransactionsBtn'), userTransactionsTableBody: getElement('userTransactionsTableBody'), userCoinTransactionsTableBody: getElement('userCoinTransactionsTableBody'), transactionsStatus: getElement('transactionsStatus'),
             tournamentResultsSection: getElement('tournament-results-section'), completedTournamentsTableBody: getElement('completedTournamentsTableBody'), tournamentResultsStatus: getElement('tournamentResultsStatus'), tournamentWinnerModalEl: getElement('tournamentWinnerModal'), tournamentWinnerModalTitle: getElement('tournamentWinnerModalTitle'), winnerModalTournamentName: getElement('winnerModalTournamentName'), winnerModalTournamentId: getElement('winnerModalTournamentId'), tournamentWinnerStatus: getElement('tournamentWinnerStatus'), tournamentWinnerForm: getElement('tournamentWinnerForm'), tournamentWinnerPlayersTableBody: getElement('tournamentWinnerPlayersTableBody'), tournamentResultNote: getElement('tournamentResultNote'), distributeWinningsBtn: getElement('distributeWinningsBtn'), finalizeTournamentResultsBtn: getElement('finalizeTournamentResultsBtn')
        };

        let componentInstances = {};
        const getComponentInstance = (element, componentType = 'Modal') => { if (!element) return null; const instanceKey = `${componentType}-${element.id}`; if (!componentInstances[instanceKey]) { try { if (componentType === 'Modal') componentInstances[instanceKey] = new bootstrap.Modal(element); else if (componentType === 'Offcanvas') componentInstances[instanceKey] = new bootstrap.Offcanvas(element); else if (componentType === 'Tab') componentInstances[instanceKey] = new bootstrap.Tab(element); else if (componentType === 'Alert') componentInstances[instanceKey] = bootstrap.Alert.getOrCreateInstance(element); else if (componentType === 'Toast') componentInstances[instanceKey] = bootstrap.Toast.getOrCreateInstance(element); else { return null; } } catch (e) { console.error(`Error creating Bootstrap ${componentType} instance for ${element.id}:`, e); return null; } } return componentInstances[instanceKey]; }
        const getModalInstance = (element) => getComponentInstance(element, 'Modal');
        const getOffcanvasInstance = (element) => getComponentInstance(element, 'Offcanvas');

        let currentAdminUser = null;
        let currentWithdrawalAction = { id: null, type: null, userId: null, amount: 0 };
        let currentDepositAction = { id: null, type: null, userId: null, amount: 0, requestKey: null };
        let currentDiamondAction = { id: null, type: null, userId: null, coinsSpent: 0 };
        let currentTournamentForResults = null;
        let currentEditingItemId = null; let currentEditingTournamentId = null; let gameDataCache = {}; let userDataCache = {}; let fullUserDataCache = {}; let dbListeners = {};
        let isAdminSetupComplete = false;
        let designatedAdminUid = null;
        let appSettings = {};
        let authUserCache = {};

        const showLoader = (show) => { if (elements.adminLoader) elements.adminLoader.style.display = show ? 'flex' : 'none'; };
        function showStatus(element, message, type = 'danger', autohide = 5000) { if (!element) return; const alertId = `status-alert-${element.id || Math.random().toString(36).substring(2)}`; element.style.display = 'block'; element.innerHTML = `<div id="${alertId}" class="alert alert-${type} alert-dismissible fade show" role="alert">${sanitizeHTML(message)}<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button></div>`; if (autohide && typeof autohide === 'number' && autohide > 0) { setTimeout(() => { const currentAlert = getElement(alertId); if (currentAlert) { try { const bsAlert = getComponentInstance(currentAlert, 'Alert'); if (bsAlert) bsAlert.close(); else currentAlert.remove(); } catch (e) { currentAlert.remove(); } } }, autohide); } }
        function clearStatus(element) { if (!element) return; element.innerHTML = '';}
        const formatDate = (timestamp) => { if (!timestamp) return 'N/A'; if (typeof timestamp === 'object' && timestamp.hasOwnProperty('.sv')) { return 'Pending...'; } const tsNumber = Number(timestamp); if (isNaN(tsNumber) || tsNumber <= 0) return 'Invalid Date'; try { const date = new Date(tsNumber); if (isNaN(date.getTime())) return 'Invalid Date'; return date.toLocaleString([], { dateStyle: 'short', timeStyle: 'short'}); } catch (e) { return 'Invalid Date'; } };
        const formatCurrency = (amount) => { const num = Number(amount); return isNaN(num) ? 'PKR --' : `PKR ${num.toFixed(2)}`; }
        const formatCoins = (amount) => { const num = Number(amount); return isNaN(num) ? '--' : `${num}`; }
        function sanitizeHTML(str) { if (str == null) return ''; str = String(str); const temp = document.createElement('div'); temp.textContent = str; return temp.innerHTML; }
        function copyToClipboard(textToCopy) { if (!textToCopy) { return; } if (navigator.clipboard && window.isSecureContext) { navigator.clipboard.writeText(textToCopy) .then(() => { const toastEl = document.createElement('div'); toastEl.className = 'toast position-fixed bottom-0 end-0 p-3 m-3 text-bg-success border-0'; toastEl.setAttribute('role', 'alert'); toastEl.setAttribute('aria-live', 'assertive'); toastEl.setAttribute('aria-atomic', 'true'); toastEl.innerHTML = '<div class="toast-body">Copied!</div>'; document.body.appendChild(toastEl); const toast = getComponentInstance(toastEl, 'Toast'); if(toast) toast.show(); else { setTimeout(() => toastEl.remove(), 3000); } toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove()); }) .catch(err => { alert('Could not copy.'); }); } else { const textArea = document.createElement("textarea"); textArea.value = textToCopy; textArea.style.position = "fixed"; textArea.style.left = "-9999px"; textArea.style.top = "0"; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try { document.execCommand('copy'); alert('Copied! (fallback)'); } catch (err) { alert('Copy failed.'); } document.body.removeChild(textArea); } }
        const tableLoadingPlaceholderHtml = (cols) => `<tr class="loading-placeholder"><td colspan="${cols}"><div class="placeholder w-100 py-3"></div></td></tr>`.repeat(3);

        function showAdminSection(sectionId) {
            console.log("Attempting to show section:", sectionId);
            if (!sectionId) {
                console.error("showAdminSection called with no sectionId. Defaulting to dashboard.");
                sectionId = 'dashboard-section';
            }

            elements.sections.forEach(sec => sec.classList.remove('active'));
            const targetSection = getElement(sectionId);

            if (targetSection) {
                targetSection.classList.add('active');
                console.log("Section activated:", sectionId);

                let title = 'Admin Panel';
                const linkElement = querySel(`#adminSidebar .nav-link[data-section="${sectionId}"]`);

                if (linkElement) {
                    const linkText = linkElement.textContent.trim() || sectionId.replace('-section', '').replace(/-/g, ' ');
                    title = linkText.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
                    const badge = linkElement.querySelector('.badge');
                    if (badge) {
                        title = title.replace(badge.textContent, '').trim();
                    }
                    elements.sidebarLinks?.forEach(link => {
                        link.classList.toggle('active', link.dataset.section === sectionId);
                    });
                } else {
                    console.warn(`Sidebar link for section ${sectionId} not found.`);
                    title = sectionId.replace('-section', '').replace(/-/g, ' ').split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
                }

                if(elements.adminPageTitle) elements.adminPageTitle.textContent = title;

                loadDataForSection(sectionId);

                const sidebarInstance = getOffcanvasInstance(elements.sidebar);
                if (sidebarInstance && sidebarInstance._isShown) {
                    sidebarInstance.hide();
                }
            } else {
                console.error("Target section element not found:", sectionId, ". Defaulting to dashboard-section.");
                if (sectionId !== 'dashboard-section') {
                    showAdminSection('dashboard-section');
                } else {
                    console.error("CRITICAL: dashboard-section not found. Cannot default.");
                }
            }
        }

        function loadDataForSection(sectionId) {
             if (!currentAdminUser || !isDesignatedAdmin(currentAdminUser.uid)) {
                console.warn("Attempted to load data without proper admin authorization.");
                 showStatus(elements.dashboardStatus || document.body.querySelector('.section.active div[id$="Status"]') || document.body, "Admin not authorized or setup issue.", "danger", false);
                return;
            }
             console.log(`Loading data for section: ${sectionId}`);
             clearStatus(elements.dashboardStatus); clearStatus(elements.gamesStatus); clearStatus(elements.promotionsStatus); clearStatus(elements.tournamentsStatus); clearStatus(elements.usersStatus); clearStatus(elements.depositRequestsStatus); clearStatus(elements.withdrawalsStatus); clearStatus(elements.settingsStatus); clearStatus(elements.transactionsStatus); clearStatus(elements.tournamentResultsStatus); clearStatus(elements.htmlGamesStatus); clearStatus(elements.diamondRedemptionStatus); clearStatus(elements.diamondTiersStatus); clearStatus(elements.tasksStatus);
             switch(sectionId) {
                 case 'dashboard-section': loadDashboardStats(); break;
                 case 'games-section': loadGames(); break;
                 case 'html-games-section': loadHtmlGames(); break;
                 case 'promotions-section': loadPromotions(); break;
                 case 'tournaments-section': loadTournaments(); break;
                 case 'tournament-results-section': loadCompletedTournamentsForResults(); break;
                 case 'users-section': loadUsers(); break;
                 case 'deposit-requests-section':
                    loadDepositRequests('pending_verification'); loadDepositRequests('completed'); loadDepositRequests('rejected');
                    const activeDepositTabBtn = querySel('#depositRequestTabs .nav-link.active') || getElement('pending-deposit-tab');
                    if (activeDepositTabBtn) getComponentInstance(activeDepositTabBtn, 'Tab')?.show();
                    break;
                 case 'withdrawals-section':
                    loadWithdrawals('pending'); loadWithdrawals('completed'); loadWithdrawals('rejected');
                    const activeWithdrawalTabBtn = querySel('#withdrawalTabs .nav-link.active') || getElement('pending-withdrawal-tab');
                    if (activeWithdrawalTabBtn) getComponentInstance(activeWithdrawalTabBtn, 'Tab')?.show();
                    break;
                 case 'diamond-redemption-section':
                    loadDiamondRequests('pending_fulfillment'); loadDiamondRequests('fulfilled'); loadDiamondRequests('rejected');
                    const activeDiamondTabBtn = querySel('#diamondRedemptionTabs .nav-link.active') || getElement('pending-diamond-tab');
                    if(activeDiamondTabBtn) getComponentInstance(activeDiamondTabBtn, 'Tab')?.show();
                    break;
                 case 'diamond-tiers-section': loadDiamondTiers(); break;
                 case 'tasks-section': loadTasks(); break;
                 case 'settings-section': loadSettings(); break;
                 case 'transactions-section': elements.userTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-muted">Enter search term and click "Fetch" to view PKR transactions.</td></tr>`; elements.userCoinTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-muted">Coin transactions will appear here.</td></tr>`; break;
                 default: console.warn("Unknown section requested:", sectionId); showStatus(elements.dashboardStatus, `Unknown section requested: ${sanitizeHTML(sectionId)}`, "warning");
             }
         }

        function isDesignatedAdmin(uid) { return designatedAdminUid && uid === designatedAdminUid; }
        async function loginAdmin(event) { event.preventDefault(); if (!auth) return; showLoader(true); const email = elements.adminEmailInput.value; const password = elements.adminPasswordInput.value; try { await signInWithEmailAndPassword(auth, email, password); showStatus(elements.adminLoginStatus, "Login successful! Loading...", "success"); } catch (error) { showStatus(elements.adminLoginStatus, `Login failed: ${error.message}`, "danger"); } finally { showLoader(false); } }
        async function logoutAdminUser() { if (!auth) return; showLoader(true); try { await signOut(auth); } catch (error) { console.error("Error signing out:", error); } finally { currentAdminUser = null; elements.mainArea.style.display = 'none'; elements.authContainer.style.display = 'block'; elements.loginSection.style.display = 'block'; elements.setupSection.style.display = 'none'; detachAllAdminListeners(); showLoader(false); } }
        async function checkAdminSetup() { const adminConfigRef = ref(db, 'admin_config/designated_admin_uid'); try { const snapshot = await get(adminConfigRef); if (snapshot.exists() && snapshot.val()) { designatedAdminUid = snapshot.val(); isAdminSetupComplete = true; return true; } else { isAdminSetupComplete = false; return false; } } catch (error) { console.error("Error checking admin setup:", error); isAdminSetupComplete = false; return false; } }
        async function setupAdmin(event) { event.preventDefault(); if (!auth) return; showLoader(true); const email = elements.setupEmailInput.value; const password = elements.setupPasswordInput.value; try { const userCredential = await createUserWithEmailAndPassword(auth, email, password); const adminUid = userCredential.user.uid; await set(ref(db, 'admin_config/designated_admin_uid'), adminUid); await set(ref(db, `users/${adminUid}/isAdmin`), true); designatedAdminUid = adminUid; isAdminSetupComplete = true; showStatus(elements.setupStatus, "Admin account created! Please login.", "success"); elements.setupSection.style.display = 'none'; elements.loginSection.style.display = 'block'; } catch (error) { showStatus(elements.setupStatus, `Setup failed: ${error.message}`, "danger"); } finally { showLoader(false); } }
        async function handleInitialLoad() { if (!auth || !db) { console.error("Firebase not ready for initial load."); return; } showLoader(true); const setupDone = await checkAdminSetup(); if (!setupDone) { elements.authContainer.style.display = 'block'; elements.setupSection.style.display = 'block'; elements.loginSection.style.display = 'none'; elements.mainArea.style.display = 'none'; showLoader(false); return; } if (!auth.currentUser) { elements.authContainer.style.display = 'block'; elements.loginSection.style.display = 'block'; elements.setupSection.style.display = 'none'; elements.mainArea.style.display = 'none'; } else { await handleAdminAuthStateChange(auth.currentUser); } showLoader(false); }
        async function handleAdminAuthStateChange(user) { if (!auth || !db) return; showLoader(true); detachAllAdminListeners(); if (user) { if (!isAdminSetupComplete) await checkAdminSetup(); if (isDesignatedAdmin(user.uid)) { currentAdminUser = user; authUserCache[user.uid] = { emailVerified: user.emailVerified }; elements.adminUserEmailDisplay.textContent = user.email; elements.authContainer.style.display = 'none'; elements.mainArea.style.display = 'block'; await loadSettings(); showAdminSection('dashboard-section'); setupRealtimeAdminListeners(); } else { currentAdminUser = null; elements.mainArea.style.display = 'none'; elements.authContainer.style.display = 'block'; elements.loginSection.style.display = 'block'; showStatus(elements.adminLoginStatus, "Not an authorized admin account.", "danger"); if (auth.currentUser) await signOut(auth); } } else { currentAdminUser = null; elements.mainArea.style.display = 'none'; elements.authContainer.style.display = 'block'; if (isAdminSetupComplete) { elements.loginSection.style.display = 'block'; elements.setupSection.style.display = 'none'; } else { elements.setupSection.style.display = 'block'; elements.loginSection.style.display = 'none'; } } showLoader(false); }

        async function loadDashboardStats() {
            if (!db) return;
            clearStatus(elements.dashboardStatus);
            Object.values(elements).filter(el => el && el.id?.startsWith('stat')).forEach(el => el.textContent = '...');

            const refsToFetch = [
                { key: 'users', path: 'users', element: elements.statTotalUsers, type: 'countDirect' },
                { key: 'games', path: 'games', element: elements.statTotalGames, type: 'countDirect' },
                { key: 'htmlGames', path: 'htmlGames', element: elements.statTotalHtmlGames, type: 'countDirect' },
                { key: 'promotions', path: 'promotions', element: elements.statTotalPromotions, type: 'countDirect' },
                {
                    key: 'tournaments', path: 'tournaments', type: 'customCount',
                    counter: (snapshot) => {
                        let activeCount = 0, finishedCount = 0;
                        if (snapshot.exists()) {
                            snapshot.forEach(child => {
                                const status = child.val()?.status;
                                if (status === 'ongoing' || status === 'upcoming') activeCount++;
                                else if (['completed', 'result', 'cancelled'].includes(status)) finishedCount++;
                            });
                        }
                        return { active: activeCount, finished: finishedCount };
                    },
                    elements: { active: elements.statActiveTournaments, finished: elements.statFinishedTournaments }
                },
                {
                    key: 'depositsPending', path: 'depositRequests', type: 'customCount',
                    counter: (snapshot) => {
                        let count = 0;
                        if (snapshot.exists()) {
                            snapshot.forEach(req => {
                                if (req.val()?.status === 'pending_verification') count++;
                            });
                        }
                        return count;
                    },
                    elements: { single: elements.statPendingDeposits },
                    badge: elements.pendingDepositCountBadge
                },
                { key: 'withdrawalsPending', path: 'withdrawals', status: 'pending', element: elements.statPendingWithdrawals, badge: elements.pendingWithdrawalCountBadge, type: 'countQuery' },
                { key: 'withdrawalsCompleted', path: 'withdrawals', status: 'completed', element: elements.statCompletedWithdrawals, type: 'countQuery' },
                { key: 'withdrawalsRejected', path: 'withdrawals', status: 'rejected', element: elements.statRejectedWithdrawals, type: 'countQuery' },
                { key: 'diamondsPending', path: 'diamondRedemptionRequests', status: 'pending_fulfillment', element: elements.statPendingDiamonds, badge: elements.pendingDiamondCountBadge, type: 'countQuery' },
            ];

            const promises = refsToFetch.map(itemConfig => {
                let queryRef = ref(db, itemConfig.path);
                if (itemConfig.type === 'countQuery' && itemConfig.status) {
                    queryRef = query(ref(db, itemConfig.path), orderByChild('status'), equalTo(itemConfig.status));
                }
                return get(queryRef).catch(err => ({ error: true, reason: err, itemKey: itemConfig.key }));
            });

            const results = await Promise.allSettled(promises);

            results.forEach((result, index) => {
                const itemConfig = refsToFetch[index];
                if (result.status === 'fulfilled' && !result.value.error) {
                    const snapshot = result.value;
                    let countData;

                    if (itemConfig.type === 'countDirect' || itemConfig.type === 'countQuery') {
                        countData = snapshot.exists() ? snapshot.size : 0;
                        if (itemConfig.element) itemConfig.element.textContent = countData;
                    } else if (itemConfig.type === 'customCount' && itemConfig.counter) {
                        countData = itemConfig.counter(snapshot);
                        if (typeof countData === 'object') {
                            if (itemConfig.elements?.active) itemConfig.elements.active.textContent = countData.active;
                            if (itemConfig.elements?.finished) itemConfig.elements.finished.textContent = countData.finished;
                        } else {
                            if (itemConfig.elements?.single) itemConfig.elements.single.textContent = countData;
                        }
                    }

                    if (itemConfig.badge) {
                        const badgeCount = (typeof countData === 'object' && countData.hasOwnProperty('single')) ? countData.single : (typeof countData !== 'object' ? countData : 0);
                        itemConfig.badge.textContent = badgeCount;
                        itemConfig.badge.style.display = badgeCount > 0 ? 'inline-block' : 'none';
                    }

                } else {
                    const reason = result.reason || result.value?.reason;
                    console.error(`Error loading dashboard stat for ${itemConfig.key}:`, reason);
                    if (itemConfig.element) itemConfig.element.textContent = 'Error';
                    else if (itemConfig.elements) {
                        if (itemConfig.elements.active) itemConfig.elements.active.textContent = 'Error';
                        if (itemConfig.elements.finished) itemConfig.elements.finished.textContent = 'Error';
                        if (itemConfig.elements.single) itemConfig.elements.single.textContent = 'Error';
                    }
                    if (itemConfig.badge) {
                        itemConfig.badge.textContent = 'Err';
                        itemConfig.badge.style.display = 'inline-block';
                    }
                    if (reason?.message?.includes("index")) {
                        showStatus(elements.dashboardStatus, `Query fail for ${itemConfig.key}. Add appropriate Firebase Realtime Database rules with '.indexOn'.`, "warning", false);
                    } else {
                        showStatus(elements.dashboardStatus, `Error loading ${itemConfig.key}: ${reason?.message || 'Unknown error'}`, "warning");
                    }
                }
            });
        }
        async function loadGames() { if (!db) return; const gamesRef = ref(db, 'games'); elements.gamesTableBody.innerHTML = tableLoadingPlaceholderHtml(4); gameDataCache = {}; clearStatus(elements.gamesStatus); try { const snapshot = await get(gamesRef); let tableHtml = ''; if (snapshot.exists()) { snapshot.forEach(childSnapshot => { const gameId = childSnapshot.key; const game = childSnapshot.val(); if (game && game.name) { gameDataCache[gameId] = game.name; tableHtml += `<tr><td><img src="${sanitizeHTML(game.imageUrl || 'https://via.placeholder.com/60x40/1E293B/94A3B8?text=N/A')}" alt="${sanitizeHTML(game.name)}" class="preview-img"></td><td>${sanitizeHTML(game.name)}</td><td><small class="text-muted">${sanitizeHTML(gameId)}</small> <i class="bi bi-clipboard copy-btn ms-1" data-target-text="${sanitizeHTML(gameId)}" title="Copy Game ID"></i></td><td class="action-buttons"><button class="btn btn-sm btn-info btn-edit-game" data-id="${sanitizeHTML(gameId)}" title="Edit Game"><i class="bi bi-pencil-square"></i></button><button class="btn btn-sm btn-danger btn-delete-game" data-id="${sanitizeHTML(gameId)}" title="Delete Game"><i class="bi bi-trash"></i></button></td></tr>`; } }); } elements.gamesTableBody.innerHTML = tableHtml || `<tr><td colspan="4" class="text-center p-3 text-muted">No esport games found.</td></tr>`; if (elements.dashboardSection?.classList.contains('active') && elements.statTotalGames) { elements.statTotalGames.textContent = Object.keys(gameDataCache).length; } } catch (error) { elements.gamesTableBody.innerHTML = `<tr><td colspan="4" class="text-center p-3 text-danger">Error: ${error.message}.</td></tr>`; showStatus(elements.gamesStatus, `Error loading esport games: ${error.message}.`, 'danger', false); if (elements.dashboardSection?.classList.contains('active') && elements.statTotalGames) elements.statTotalGames.textContent = 'Error'; } }
        async function loadHtmlGames() { if (!db) return; const gamesRef = ref(db, 'htmlGames'); elements.htmlGamesTableBody.innerHTML = tableLoadingPlaceholderHtml(5); clearStatus(elements.htmlGamesStatus); try { const snapshot = await get(gamesRef); let tableHtml = ''; let gameCount = 0; if (snapshot.exists()) { gameCount = snapshot.size; snapshot.forEach(childSnapshot => { const gameId = childSnapshot.key; const game = childSnapshot.val(); if (game && game.name) { tableHtml += `<tr><td><img src="${sanitizeHTML(game.iconUrl || 'https://via.placeholder.com/40x40/1E293B/94A3B8?text=G')}" alt="${sanitizeHTML(game.name)}" class="preview-img" style="height: 40px; width: 40px;"></td><td>${sanitizeHTML(game.name)}</td><td>${formatCoins(game.costToPlayCoins || 0)}</td><td><span class="status-badge text-bg-${game.enabled ? 'success' : 'secondary'}">${game.enabled ? 'Yes' : 'No'}</span></td><td class="action-buttons"><button class="btn btn-sm btn-info btn-edit-html-game" data-id="${sanitizeHTML(gameId)}" title="Edit"><i class="bi bi-pencil-square"></i></button><button class="btn btn-sm btn-danger btn-delete-html-game" data-id="${sanitizeHTML(gameId)}" title="Delete"><i class="bi bi-trash"></i></button></td></tr>`; } }); } elements.htmlGamesTableBody.innerHTML = tableHtml || `<tr><td colspan="5" class="text-center p-3 text-muted">No HTML games found.</td></tr>`; if (elements.dashboardSection?.classList.contains('active') && elements.statTotalHtmlGames) { elements.statTotalHtmlGames.textContent = gameCount; } } catch (error) { elements.htmlGamesTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-danger">Error: ${error.message}.</td></tr>`; showStatus(elements.htmlGamesStatus, `Error loading HTML games: ${error.message}.`, 'danger', false); if (elements.dashboardSection?.classList.contains('active') && elements.statTotalHtmlGames) elements.statTotalHtmlGames.textContent = 'Error'; } }
        async function loadPromotions() { if (!db) return; const promotionsRef = ref(db, 'promotions'); elements.promotionsTableBody.innerHTML = tableLoadingPlaceholderHtml(3); clearStatus(elements.promotionsStatus); let promoCount = 0; try { const snapshot = await get(promotionsRef); let tableHtml = ''; if (snapshot.exists()) { promoCount = snapshot.size; snapshot.forEach(childSnapshot => { const promoId = childSnapshot.key; const promo = childSnapshot.val(); if (promo && promo.imageUrl) { const displayLink = promo.link ? sanitizeHTML(promo.link) : ''; const shortLink = displayLink.length > 50 ? displayLink.substring(0, 50) + '...' : displayLink; tableHtml += `<tr><td><img src="${sanitizeHTML(promo.imageUrl)}" alt="Promotion" class="preview-img"></td><td>${promo.link ? `<a href="${displayLink}" target="_blank" class="text-info" title="${displayLink}">${shortLink}</a>` : '<span class="text-muted">No Link</span>'}</td><td class="action-buttons"><button class="btn btn-sm btn-info btn-edit-promo" data-id="${sanitizeHTML(promoId)}" title="Edit Promotion"><i class="bi bi-pencil-square"></i></button><button class="btn btn-sm btn-danger btn-delete-promo" data-id="${sanitizeHTML(promoId)}" title="Delete Promotion"><i class="bi bi-trash"></i></button></td></tr>`; } }); } elements.promotionsTableBody.innerHTML = tableHtml || `<tr><td colspan="3" class="text-center p-3 text-muted">No promotions found.</td></tr>`; if (elements.dashboardSection?.classList.contains('active') && elements.statTotalPromotions) { elements.statTotalPromotions.textContent = promoCount; } } catch (error) { elements.promotionsTableBody.innerHTML = `<tr><td colspan="3" class="text-center p-3 text-danger">Error: ${error.message}.</td></tr>`; showStatus(elements.promotionsStatus, `Error loading promotions: ${error.message}.`, 'danger', false); if (elements.dashboardSection?.classList.contains('active') && elements.statTotalPromotions) elements.statTotalPromotions.textContent = 'Error'; } }
        async function loadTournaments() { if (!db) return; const tournamentsRef = ref(db, 'tournaments'); if (Object.keys(gameDataCache).length === 0) await loadGames(); elements.tournamentsTableBody.innerHTML = tableLoadingPlaceholderHtml(8); clearStatus(elements.tournamentsStatus); try { const snapshot = await get(tournamentsRef); let activeCount = 0; let finishedCount = 0; let tableHtml = ''; if (snapshot.exists()) { snapshot.forEach(childSnapshot => { const tournamentId = childSnapshot.key; const t = childSnapshot.val(); if (t && t.name && t.gameId && t.status) { const gameName = gameDataCache[t.gameId] || `<small class="text-warning" title="ID: ${t.gameId}">Unknown</small>`; let statusClass = 'secondary'; if (t.status === 'ongoing') { statusClass = 'success'; activeCount++; } else if (t.status === 'upcoming') { statusClass = 'info'; activeCount++; } else if (['completed', 'result', 'cancelled'].includes(t.status)) { finishedCount++; if (t.status === 'result') statusClass = 'primary'; else if (t.status === 'cancelled') statusClass = 'danger';} const statusBadge = `<span class="status-badge text-bg-${statusClass}">${t.status}</span>`; const registeredCount = t.registeredPlayers ? Object.keys(t.registeredPlayers).length : 0; const maxPlayers = t.maxPlayers > 0 ? `/${t.maxPlayers}` : ''; const playersDisplay = `${registeredCount}${maxPlayers}`; const feeDisplay = (t.entryFee > 0 ? `${formatCurrency(t.entryFee)}` : '') + ((t.entryFee > 0 && t.entryFeeCoins > 0) ? ' / ' : '') + (t.entryFeeCoins > 0 ? `<span class="text-coin">${formatCoins(t.entryFeeCoins)} <i class="bi bi-coin"></i></span>` : ''); const prizeDisplay = (t.prizePool > 0 ? `${formatCurrency(t.prizePool)}` : '') + ((t.prizePool > 0 && t.prizePoolCoins > 0) ? ' / ' : '') + (t.prizePoolCoins > 0 ? `<span class="text-coin">${formatCoins(t.prizePoolCoins)} <i class="bi bi-coin"></i></span>` : ''); tableHtml += `<tr><td>${sanitizeHTML(t.name)}</td><td>${gameName}</td><td>${feeDisplay || 'Free'}</td><td>${prizeDisplay || 'Participation'}</td><td>${formatDate(t.startTime)}</td><td>${statusBadge}</td><td>${playersDisplay}</td><td class="action-buttons"><button class="btn btn-sm btn-info btn-edit-tournament" data-id="${sanitizeHTML(tournamentId)}" title="Edit"><i class="bi bi-pencil-square"></i></button><button class="btn btn-sm btn-secondary btn-view-registered" data-id="${sanitizeHTML(tournamentId)}" data-name="${sanitizeHTML(t.name)}" title="View Players"><i class="bi bi-people"></i></button><button class="btn btn-sm btn-danger btn-delete-tournament" data-id="${sanitizeHTML(tournamentId)}" title="Delete"><i class="bi bi-trash"></i></button></td></tr>`; } }); } elements.tournamentsTableBody.innerHTML = tableHtml || `<tr><td colspan="8" class="text-center p-3 text-muted">No tournaments found.</td></tr>`; if (elements.dashboardSection?.classList.contains('active')) { if(elements.statActiveTournaments) elements.statActiveTournaments.textContent = activeCount; if(elements.statFinishedTournaments) elements.statFinishedTournaments.textContent = finishedCount; } } catch (error) { elements.tournamentsTableBody.innerHTML = `<tr><td colspan="8" class="text-center p-3 text-danger">Error: ${error.message}.</td></tr>`; showStatus(elements.tournamentsStatus, `Error: ${error.message}.`, "danger", false); if (elements.dashboardSection?.classList.contains('active')) { if(elements.statActiveTournaments) elements.statActiveTournaments.textContent = 'Error'; if(elements.statFinishedTournaments) elements.statFinishedTournaments.textContent = 'Error'; } } }
        
        function renderUsersTable(usersArray) {
            let tableHtml = '';
            if (usersArray?.length > 0) {
                usersArray.sort((a, b) => (a.displayName || '').localeCompare(b.displayName || '', undefined, { sensitivity: 'base' }));
                usersArray.forEach(user => {
                    if (user?.email && user.uid) {
                        const isVerified = authUserCache[user.uid]?.emailVerified || false;
                        const statusBadge = isVerified 
                            ? `<span class="badge text-bg-success">Verified</span>` 
                            : `<span class="badge text-bg-warning">Not Verified</span>`;

                        tableHtml += `
                            <tr data-user-id="${user.uid}">
                                <td>${sanitizeHTML(user.gameUid || 'N/A')}</td>
                                <td>${sanitizeHTML(user.displayName || 'N/A')}</td>
                                <td class="wrap-text">${sanitizeHTML(user.email)}</td>
                                <td>${formatCurrency(user.balance)}</td>
                                <td><span class="text-coin">${formatCoins(user.gameCoins || 0)}</span></td>
                                <td id="referral-count-${user.uid}">...</td>
                                <td>${statusBadge}</td>
                                <td class="action-buttons">
                                    <button class="btn btn-sm btn-info btn-view-user" data-id="${sanitizeHTML(user.uid)}" title="View/Edit"><i class="bi bi-eye"></i></button>
                                </td>
                            </tr>`;
                    }
                });
            }
            elements.usersTableBody.innerHTML = tableHtml || `<tr><td colspan="8" class="text-center p-3 text-muted">No users found.</td></tr>`;
            if (usersArray?.length > 0) {
                populateReferralCountsInTable(usersArray);
            }
        }
        
        async function populateReferralCountsInTable(usersArray) {
            for (const user of usersArray) {
                const countCell = getElement(`referral-count-${user.uid}`);
                if (countCell) {
                    try {
                        const q = query(ref(db, 'users'), orderByChild('referredBy'), equalTo(user.uid));
                        const snapshot = await get(q);
                        countCell.textContent = snapshot.exists() ? snapshot.size : 0;
                    } catch(e) {
                        console.error(`Could not fetch referral count for ${user.uid}`, e);
                        countCell.textContent = 'Err';
                    }
                }
            }
        }
        
        async function loadUsers() {
            if (!db) return;
            const usersRef = ref(db, 'users');
            elements.usersTableBody.innerHTML = tableLoadingPlaceholderHtml(8);
            fullUserDataCache = {};
            clearStatus(elements.usersStatus);
            elements.userSearchInput.value = '';

            const listenerKey = 'users';
            if (dbListeners[listenerKey]) {
                try {
                    off(usersRef, 'value', dbListeners[listenerKey]);
                    delete dbListeners[listenerKey];
                } catch(e) { console.warn("Error detaching old users listener:", e); }
            }
            
            // This is a simplified frontend approach. It won't fetch auth status for all users at once due to SDK limitations.
            // It will rely on the `handleAdminAuthStateChange` to populate the admin's status and show others as "Not Verified"
            // unless their data is fetched individually (which would be inefficient here).
            // A Cloud Function is the recommended way to sync auth properties to the database for large scale apps.
            dbListeners[listenerKey] = onValue(usersRef, async (snapshot) => {
                let userCount = 0;
                const usersArray = [];
                fullUserDataCache = {};
                if (snapshot.exists()) {
                    snapshot.forEach(childSnapshot => {
                        userCount++;
                        const userId = childSnapshot.key;
                        const user = childSnapshot.val();
                        if (user && user.email) {
                            user.uid = userId;
                            if(!authUserCache[userId]) {
                                authUserCache[userId] = { emailVerified: false }; // Default unless known
                            }
                            user.emailVerified = authUserCache[userId].emailVerified;
                            fullUserDataCache[userId] = user;
                            usersArray.push(user);
                        }
                    });
                }
                
                renderUsersTable(usersArray);
                
                if (elements.dashboardSection?.classList.contains('active') && elements.statTotalUsers) {
                    elements.statTotalUsers.textContent = userCount;
                }
            }, (error) => {
                elements.usersTableBody.innerHTML = `<tr><td colspan="8" class="text-center p-3 text-danger">Error: ${error.message}.</td></tr>`;
                showStatus(elements.usersStatus, `Error: ${error.message}.`, "danger", false);
                fullUserDataCache = {};
                if (elements.dashboardSection?.classList.contains('active') && elements.statTotalUsers) elements.statTotalUsers.textContent = 'Error';
            });
        }
        
        function filterUsers() {
            const searchTerm = elements.userSearchInput.value.toLowerCase().trim();
            const filteredUsers = Object.values(fullUserDataCache).filter(user =>
                user.displayName?.toLowerCase().includes(searchTerm) ||
                user.email?.toLowerCase().includes(searchTerm) ||
                user.uid?.toLowerCase().includes(searchTerm) ||
                user.gameUid?.toString().toLowerCase().includes(searchTerm)
            );
            renderUsersTable(filteredUsers);
        }

        async function loadSettings() { if (!db) return; elements.appSettingsForm?.querySelectorAll('input, textarea, button').forEach(el => el.disabled = true); clearStatus(elements.settingsStatus); try { const snapshot = await get(ref(db, 'settings')); if (snapshot.exists()) { appSettings = snapshot.val() || {}; elements.settingLogoUrlInput.value = appSettings.logoUrl || ''; elements.settingAppNameInput.value = appSettings.appName || ''; elements.settingMinWithdrawInput.value = appSettings.minWithdraw || 0; elements.settingReferralBonusInput.value = appSettings.referralBonus || 0; elements.settingNewUserBonusInput.value = appSettings.newUserBonus || 0; elements.settingNewUserGameCoinsInput.value = appSettings.gameCoinOptions?.newUserGameCoins || 0; elements.settingDailyCheckinRewardsInput.value = (appSettings.dailyCheckinRewards || []).join(','); elements.settingSupportContactInput.value = appSettings.supportContact || ''; elements.settingPaymentAccountDetailsInput.value = appSettings.paymentAccountDetails || ''; elements.settingPolicyPrivacyInput.value = appSettings.policyPrivacy || ''; elements.settingPolicyTermsInput.value = appSettings.policyTerms || ''; elements.settingPolicyRefundInput.value = appSettings.policyRefund || ''; elements.settingPolicyFairPlayInput.value = appSettings.policyFairPlay || ''; if(elements.adminHeaderLogo) { const logoUrl = appSettings.logoUrl; elements.adminHeaderLogo.src = logoUrl || 'https://via.placeholder.com/35/1E293B/94A3B8?text=L'; elements.adminHeaderLogo.style.display = logoUrl ? 'inline-block' : 'none'; elements.adminHeaderLogo.alt = appSettings.appName ? `${appSettings.appName} Logo` : 'Logo'; } document.title = `${appSettings.appName || 'Gaming Tournament'} - Admin Panel`; } else { showStatus(elements.settingsStatus, "No settings found. Configure and save.", "info", false); elements.appSettingsForm.reset(); appSettings = {}; if(elements.adminHeaderLogo) elements.adminHeaderLogo.style.display = 'none'; document.title = 'Admin Panel'; } } catch (error) { showStatus(elements.settingsStatus, `Error: ${error.message}.`, "danger", false); appSettings = {}; if(elements.adminHeaderLogo) elements.adminHeaderLogo.style.display = 'none'; document.title = 'Admin Panel'; } finally { elements.appSettingsForm?.querySelectorAll('input, textarea, button').forEach(el => el.disabled = false); } }
        const IMGBB_API_KEY = '1579b196953465c653d3639ab091448c';
        async function uploadToImgBB(file, statusElement) { if (!file) throw new Error("File not selected."); if (!IMGBB_API_KEY || IMGBB_API_KEY === 'YOUR_IMGBB_API_KEY_PLACEHOLDER') { throw new Error("ImgBB API Key not set. Please replace 'YOUR_IMGBB_API_KEY_PLACEHOLDER' in the script."); } const formData = new FormData(); formData.append('image', file); if (statusElement) { statusElement.textContent = 'Uploading...'; statusElement.style.color = 'var(--text-secondary)'; statusElement.style.display = 'block'; } try { const response = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, { method: 'POST', body: formData }); if (!response.ok) { let errorMsg = `ImgBB upload failed: HTTP ${response.status}`; try { const errorData = await response.json(); errorMsg += ` - ${errorData?.error?.message || response.statusText}`; } catch (e) {} throw new Error(errorMsg); } const data = await response.json(); if (data.success) { if (statusElement) statusElement.textContent = 'Upload complete!'; return data.data.url; } else { throw new Error(`ImgBB upload failed: ${data.error?.message || 'Unknown error'}`); } } catch (error) { if (statusElement) { statusElement.textContent = `Upload Error: ${error.message}`; statusElement.style.color = 'var(--danger-color)'; } throw error; } }
        async function saveGame() { if (!db) return; const gameId = elements.gameEditId.value; const isEditing = !!gameId; const name = elements.gameNameInput.value.trim(); const imageUrlInput = elements.gameImageUrlInput.value.trim(); const imageFile = elements.gameImageFileInput.files[0]; const statusEl = elements.gameStatus; const imgbbStatusEl = elements.gameForm?.querySelector('.imgbb-upload-status'); clearStatus(statusEl); if (imgbbStatusEl) { imgbbStatusEl.textContent = ''; imgbbStatusEl.style.display = 'none'; } if (!name) { showStatus(statusEl, "Game Name is required.", "warning"); return; } if (!imageUrlInput && !imageFile && !isEditing) { showStatus(statusEl, "Image URL or File Upload required for new game.", "warning"); return; } if (!imageUrlInput && !imageFile && isEditing && !gameDataCache[gameId]?.imageUrl) { showStatus(statusEl, "Image URL cannot be empty when editing an existing game without a new file.", "warning"); return;} showLoader(true); elements.saveGameBtn.disabled = true; let finalImageUrl = imageUrlInput; try { if (imageFile) { finalImageUrl = await uploadToImgBB(imageFile, imgbbStatusEl); } if (!finalImageUrl) { throw new Error("Image URL is missing."); } const gameData = { name: name, imageUrl: finalImageUrl }; if (isEditing) { gameData.updatedAt = serverTimestamp(); await update(ref(db, `games/${gameId}`), gameData); showStatus(elements.gamesStatus, "Game updated!", "success", 3000); } else { gameData.createdAt = serverTimestamp(); await set(push(ref(db, 'games')), gameData); showStatus(elements.gamesStatus, "Game added!", "success", 3000); } elements.gameForm.reset(); elements.gameEditId.value = ''; if (imgbbStatusEl) { imgbbStatusEl.textContent = ''; imgbbStatusEl.style.display = 'none'; } getModalInstance(elements.gameModalEl)?.hide(); loadGames(); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); if (imgbbStatusEl && !imgbbStatusEl.textContent.includes('Error')) { imgbbStatusEl.style.display = 'none'; } } finally { showLoader(false); elements.saveGameBtn.disabled = false; } }
        async function savePromotion() { if (!db) return; const promoId = elements.promotionEditId.value; const isEditing = !!promoId; const promoLink = elements.promoLinkInput.value.trim(); const imageUrlInput = elements.promoImageUrlInput.value.trim(); const imageFile = elements.promoImageFileInput.files[0]; const statusEl = elements.promotionStatus; const imgbbStatusEl = elements.promotionForm?.querySelector('.imgbb-upload-status'); clearStatus(statusEl); if (imgbbStatusEl) { imgbbStatusEl.textContent = ''; imgbbStatusEl.style.display = 'none'; } if (!imageUrlInput && !imageFile && !isEditing) { showStatus(statusEl, "Image URL or File Upload required for new promotion.", "warning"); return; } if (!imageUrlInput && !imageFile && isEditing && !promoId) { showStatus(statusEl, "Image URL cannot be empty when editing.", "warning"); return; } showLoader(true); elements.savePromotionBtn.disabled = true; let finalImageUrl = imageUrlInput; try { if (imageFile) { finalImageUrl = await uploadToImgBB(imageFile, imgbbStatusEl); } if (!finalImageUrl) { throw new Error("Image URL is missing."); } const promoData = { imageUrl: finalImageUrl, link: promoLink || null }; if (isEditing) { promoData.updatedAt = serverTimestamp(); await update(ref(db, `promotions/${promoId}`), promoData); showStatus(elements.promotionsStatus, "Promotion updated!", "success", 3000); } else { promoData.createdAt = serverTimestamp(); await set(push(ref(db, 'promotions')), promoData); showStatus(elements.promotionsStatus, "Promotion added!", "success", 3000); } elements.promotionForm.reset(); elements.promotionEditId.value = ''; if (imgbbStatusEl) { imgbbStatusEl.textContent = ''; imgbbStatusEl.style.display = 'none'; } getModalInstance(elements.promotionModalEl)?.hide(); loadPromotions(); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); if (imgbbStatusEl && !imgbbStatusEl.textContent.includes('Error')) { imgbbStatusEl.style.display = 'none'; } } finally { showLoader(false); elements.savePromotionBtn.disabled = false; } }
        async function saveTournament(event) { event.preventDefault(); if (!db) return; const statusEl = elements.addTournamentStatus; clearStatus(statusEl); const gameId = elements.tournamentGameSelect.value; const name = elements.tournamentNameInput.value.trim(); const startTimeStr = elements.tournamentStartTimeInput.value; const entryFee = parseFloat(elements.tournamentEntryFeeInput.value) || 0; const entryFeeCoins = parseInt(elements.tournamentEntryFeeCoinsInput.value) || 0; const prizePool = parseFloat(elements.tournamentPrizePoolInput.value) || 0; const prizePoolCoins = parseInt(elements.tournamentPrizePoolCoinsInput.value) || 0; const perKillPrize = parseFloat(elements.tournamentPerKillInput.value) || 0; const perKillPrizeCoins = parseInt(elements.tournamentPerKillCoinsInput.value) || 0; const maxPlayers = parseInt(elements.tournamentMaxPlayersInput.value) || 0; if (!gameId || !name || !startTimeStr) { showStatus(statusEl, "Game, Name, and Start Time required.", "warning"); return; } let startTimeTimestamp; try { startTimeTimestamp = new Date(startTimeStr).getTime(); if (isNaN(startTimeTimestamp)) throw new Error('Invalid Date'); } catch (e) { showStatus(statusEl, "Invalid Start Date & Time.", "warning"); return; } if (entryFee < 0 || prizePool < 0 || perKillPrize < 0 || maxPlayers < 0 || entryFeeCoins < 0 || prizePoolCoins < 0 || perKillPrizeCoins < 0) { showStatus(statusEl, "Numeric values cannot be negative.", "warning"); return; } const tournamentData = { gameId, name, startTime: startTimeTimestamp, status: elements.tournamentStatusSelect.value, entryFee, entryFeeCoins, prizePool, prizePoolCoins, perKillPrize, perKillPrizeCoins, maxPlayers, tags: elements.tournamentTagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag), description: elements.tournamentDescriptionInput.value.trim(), roomId: elements.tournamentRoomIdInput.value.trim() || null, roomPassword: elements.tournamentRoomPasswordInput.value.trim() || null, showIdPass: elements.tournamentShowIdPassCheckbox.checked, updatedAt: serverTimestamp() }; showLoader(true); elements.saveTournamentBtn.disabled = true; try { if (currentEditingTournamentId) { const tRef = ref(db, `tournaments/${currentEditingTournamentId}`); const existing = await get(tRef); if (existing.exists() && existing.val().registeredPlayers) tournamentData.registeredPlayers = existing.val().registeredPlayers; await update(tRef, tournamentData); showStatus(elements.tournamentsStatus, "Tournament updated!", "success", 3000); } else { tournamentData.createdAt = serverTimestamp(); await set(push(ref(db, 'tournaments')), tournamentData); showStatus(elements.tournamentsStatus, "Tournament added!", "success", 3000); } elements.tournamentForm.reset(); currentEditingTournamentId = null; getModalInstance(elements.addTournamentModalEl)?.hide(); loadTournaments(); loadDashboardStats(); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); } finally { showLoader(false); elements.saveTournamentBtn.disabled = false; } }
        async function deleteGame(gameId) { if (!db || !gameId) return; if (!confirm(`DELETE Game ID: ${gameId}? OK?`)) return; showLoader(true); const statusEl = elements.gamesStatus; clearStatus(statusEl); try { await remove(ref(db, `games/${gameId}`)); delete gameDataCache[gameId]; showStatus(statusEl, "Game deleted.", "success", 3000); loadGames(); loadDashboardStats(); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); } finally { showLoader(false); } }
        async function deleteHtmlGame(gameId) { if (!db || !gameId) return; if (!confirm(`DELETE HTML Game ID: ${gameId}? OK?`)) return; showLoader(true); const statusEl = elements.htmlGamesStatus; clearStatus(statusEl); try { await remove(ref(db, `htmlGames/${gameId}`)); showStatus(statusEl, "HTML Game deleted.", "success", 3000); loadHtmlGames(); loadDashboardStats(); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); } finally { showLoader(false); } }
        async function deletePromotion(promoId) { if (!db || !promoId) return; if (!confirm(`DELETE Promotion ID: ${promoId}? OK?`)) return; showLoader(true); const statusEl = elements.promotionsStatus; clearStatus(statusEl); try { await remove(ref(db, `promotions/${promoId}`)); showStatus(statusEl, "Promotion deleted.", "success", 3000); loadPromotions(); loadDashboardStats(); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); } finally { showLoader(false); } }
        async function deleteTournament(tournamentId) { if (!db || !tournamentId) return; if (!confirm(`DELETE Tournament ID: ${tournamentId}?`)) return; showLoader(true); const statusEl = elements.tournamentsStatus; clearStatus(statusEl); try { await remove(ref(db, `tournaments/${tournamentId}`)); showStatus(statusEl, "Tournament deleted.", "success", 3000); loadTournaments(); loadDashboardStats(); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); } finally { showLoader(false); } }
        async function saveNewUser() { if (!auth || !db) return; const statusEl = elements.addUserStatus; clearStatus(statusEl); const name = elements.newUserNameInput.value.trim(); const email = elements.newUserEmailInput.value.trim(); const password = elements.newUserPasswordInput.value; const initialBalanceStr = elements.newUserInitialBalanceInput.value; if (!name || !email || !password) { showStatus(statusEl, "Name, Email, Password required.", "warning"); return; } if (password.length < 6) { showStatus(statusEl, "Password min 6 chars.", "warning"); return; } const initialBalance = parseFloat(initialBalanceStr) || 0; if (initialBalance < 0) { showStatus(statusEl, "Initial Balance cannot be negative.", "warning"); return; } if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) { showStatus(statusEl, "Invalid Email format.", "warning"); return; } showLoader(true); elements.saveNewUserBtn.disabled = true; try { const referralCode = Math.random().toString(36).substring(2, 10).toUpperCase(); const cred = await createUserWithEmailAndPassword(auth, email, password); const uid = cred.user.uid; const userData = { uid: uid, email: email, displayName: name, balance: initialBalance, winningCash: 0, bonusCash: 0, gameCoins: 0, status: 'active', createdAt: serverTimestamp(), referralCode: referralCode, isAdmin: false, referralEarnings: 0, totalEarnings: 0, totalMatches: 0, wonMatches: 0 }; await set(ref(db, `users/${uid}`), userData); await sendEmailVerification(cred.user); showStatus(statusEl, `User ${name} created and verification email sent!`, "success", 4000); elements.addUserForm.reset(); getModalInstance(elements.addUserModalEl)?.hide(); loadDashboardStats(); } catch (error) { let msg = `Error: ${error.message}`; if (error.code === 'auth/email-already-in-use') msg = "Email already registered."; else if (error.code === 'auth/weak-password') msg = "Password too weak."; else if (error.code === 'auth/invalid-email') msg = "Invalid email format."; else if (error.code === 'permission-denied') msg = "Permission denied. Check Rules."; showStatus(statusEl, msg, "danger", false); } finally { showLoader(false); elements.saveNewUserBtn.disabled = false; } }
        async function updateUserBalance(event) { event.preventDefault(); if (!db) return; const statusEl = elements.balanceUpdateStatus; clearStatus(statusEl); const userId = elements.editUserUid.value; const amountStr = elements.balanceUpdateAmountInput.value; const type = elements.balanceUpdateTypeSelect.value; const reason = elements.balanceUpdateReasonInput.value.trim(); if (!userId || !amountStr || !type || !reason) { showStatus(statusEl, "All fields required.", "warning"); return; } const amount = parseFloat(amountStr); if (isNaN(amount) || amount === 0) { showStatus(statusEl, "Invalid or zero amount.", "warning"); return; } showLoader(true); const userRefPath = `users/${userId}`; const updates = {}; try { const userSnapshot = await get(ref(db, userRefPath)); if (!userSnapshot.exists()) throw new Error(`User ${userId} not found.`); const user = userSnapshot.val(); let logType = ''; let txPath = `transactions/${userId}`; let isCoinTx = false; if (type === 'gameCoins') { const currentCoins = Number(user.gameCoins || 0); const newCoins = currentCoins + amount; if (newCoins < 0) throw new Error("Game Coins cannot be negative."); updates[`${userRefPath}/gameCoins`] = newCoins; logType = amount > 0 ? 'admin_coin_add' : 'admin_coin_deduct'; txPath = `coinTransactions/${userId}`; isCoinTx = true; } else { const currentBalance = Number(user.balance || 0); const currentWinning = Number(user.winningCash || 0); const currentBonus = Number(user.bonusCash || 0); let newBalance = currentBalance; let newWinning = currentWinning; let newBonus = currentBonus; switch (type) { case 'balance': newBalance += amount; updates[`${userRefPath}/balance`] = newBalance; logType = amount > 0 ? 'admin_deposit' : 'admin_deduction'; break; case 'winningCash': newWinning += amount; newBalance += amount; if (newWinning < 0) throw new Error("Winning cash cannot be negative."); updates[`${userRefPath}/winningCash`] = newWinning; updates[`${userRefPath}/balance`] = newBalance; logType = amount > 0 ? 'admin_winning_add' : 'admin_winning_deduct'; break; case 'bonusCash': newBonus += amount; newBalance += amount; if (newBonus < 0) throw new Error("Bonus cash cannot be negative."); updates[`${userRefPath}/bonusCash`] = newBonus; updates[`${userRefPath}/balance`] = newBalance; logType = amount > 0 ? 'admin_bonus_add' : 'admin_bonus_deduct'; break; default: throw new Error("Invalid balance type."); } if (newBalance < 0 && !confirm(`Warning: Negative total balance (${formatCurrency(newBalance)}). Proceed?`)) { showLoader(false); showStatus(statusEl, "Update cancelled.", "info"); return; } } const txKey = push(ref(db, txPath)).key; const txData = { type: logType, amount: amount, timestamp: serverTimestamp(), description: `Admin Update: ${reason}`, status: 'completed', adminUid: currentAdminUser.uid }; updates[`${txPath}/${txKey}`] = txData; await update(ref(db), updates); const updatedUserSnap = await get(ref(db, userRefPath)); if(updatedUserSnap.exists()) { const u = updatedUserSnap.val(); elements.userDetailBalance.textContent = (u.balance || 0).toFixed(2); elements.userDetailWinning.textContent = (u.winningCash || 0).toFixed(2); elements.userDetailBonus.textContent = (u.bonusCash || 0).toFixed(2); elements.userDetailCoins.textContent = (u.gameCoins || 0); if (fullUserDataCache[userId]) { fullUserDataCache[userId] = {...fullUserDataCache[userId], ...u}; } if (userDataCache[userId]) { userDataCache[userId] = {...userDataCache[userId], ...u};} } showStatus(statusEl, "Balance updated!", "success", 3000); elements.updateBalanceForm.reset(); } catch (error) { showStatus(statusEl, `Error: ${error.message}`, "danger", false); } finally { showLoader(false); } }
        async function toggleUserBlock(event) { const button = event.target.closest('button'); if (!button || !db) return; const userId = button.dataset.id; const currentAction = button.dataset.action; if (!userId || !currentAction) return; const newStatus = currentAction === 'block' ? 'blocked' : 'active'; if (!confirm(`Confirm ${currentAction} user ${userId}?`)) return; showLoader(true); button.disabled = true; const modalVisible = getModalInstance(elements.userModalEl)?._isShown; const statusEl = modalVisible && elements.editUserUid.value === userId ? elements.balanceUpdateStatus : elements.usersStatus; clearStatus(statusEl); try { await set(ref(db, `users/${userId}/status`), newStatus); if (fullUserDataCache[userId]) fullUserDataCache[userId].status = newStatus; if (userDataCache[userId]) userDataCache[userId].status = newStatus; showStatus(statusEl, `User ${newStatus} successfully!`, "success", 3000); if (modalVisible && elements.editUserUid.value === userId) { elements.userDetailStatus.textContent = newStatus.charAt(0).toUpperCase() + newStatus.slice(1); elements.userDetailStatus.className = `fw-bold text-${newStatus === 'active' ? 'success' : 'danger'}`; button.textContent = newStatus === 'active' ? 'Block User' : 'Unblock User'; button.className = `btn btn-sm ${newStatus === 'active' ? 'btn-danger' : 'btn-success'}`; button.dataset.action = newStatus === 'active' ? 'block' : 'unblock'; } filterUsers(); } catch (error) { showStatus(statusEl, `Error ${currentAction}ing user: ${error.message}.`, "danger", false); } finally { showLoader(false); button.disabled = false; } }
        async function deleteUser(userId) { if (!db || !userId) return; const userName = fullUserDataCache[userId]?.displayName || fullUserDataCache[userId]?.email || userId; if (!confirm(`DELETE USER: ${userName} (UID: ${userId})?\nWARNING: Database entry ONLY. Auth user NOT deleted.`)) return; showLoader(true); const statusEl = elements.usersStatus; clearStatus(statusEl); const modal = getModalInstance(elements.userModalEl); if (modal?._isShown) modal.hide(); try { await remove(ref(db, `users/${userId}`)); delete fullUserDataCache[userId]; delete userDataCache[userId]; showStatus(statusEl, `User ${userName} deleted from Database.`, "success", 5000); filterUsers(); loadDashboardStats(); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); } finally { showLoader(false); } }
        async function openWithdrawalActionModal(withdrawalId, type) { if (!db || !withdrawalId || !type) return; showLoader(true); currentWithdrawalAction = { id: withdrawalId, type: type, userId: null, amount: 0 }; elements.withdrawalRejectReasonInput.value = ''; elements.withdrawalApproveNoteInput.value = ''; elements.withdrawalRejectReasonDiv.style.display = 'none'; elements.withdrawalApproveNoteDiv.style.display = 'none'; elements.withdrawalRejectReasonInput.required = false; elements.withdrawalApproveNoteInput.required = false; clearStatus(elements.withdrawalActionStatus); elements.approveWithdrawalBtn.style.display = 'inline-block'; elements.rejectWithdrawalBtn.style.display = 'inline-block'; elements.approveWithdrawalBtn.disabled = false; elements.rejectWithdrawalBtn.disabled = false; const withdrawalRef = ref(db, `withdrawals/${withdrawalId}`); try { const snapshot = await get(withdrawalRef); if (!snapshot.exists()) throw new Error(`Withdrawal ${withdrawalId} not found.`); const w = snapshot.val(); currentWithdrawalAction.userId = w.userId; currentWithdrawalAction.amount = Number(w.amount || 0); if (w.status !== 'pending') { alert(`Request already processed (Status: ${w.status}).`); showLoader(false); return; } let userDisplay = `UID: ${w.userId}`; const userId = w.userId; if (userId && userDataCache[userId]) { const u = userDataCache[userId]; userDisplay = `${sanitizeHTML(u.displayName)} (<small class="text-muted" title="${userId}">${sanitizeHTML(u.email)}</small>)`; } else if (userId) { try { const userSnap = await get(ref(db, `users/${userId}`)); if (userSnap.exists()) { const u = userSnap.val(); userDataCache[userId] = { displayName: u.displayName || 'N/A', email: u.email || userId, status: u.status || 'unknown' }; userDisplay = `${sanitizeHTML(u.displayName)} (<small class="text-muted" title="${userId}">${sanitizeHTML(u.email)}</small>)`; } else { userDataCache[userId] = { displayName: 'Unknown User', email: userId, status: 'deleted' }; userDisplay = `Unknown User (<small class="text-muted" title="${userId}">${userId}</small>)`; } } catch (err) { userDataCache[userId] = { displayName: 'Error Fetching', email: userId, status: 'error' }; userDisplay = `Error Fetching (<small class="text-muted" title="${userId}">${userId}</small>)`; } } let methodDisplay = `${sanitizeHTML(w.methodDetails?.methodName || 'N/A')} - ${sanitizeHTML(w.methodDetails?.accountInfo || 'N/A')}`; elements.withdrawalDetailId.textContent = withdrawalId; elements.withdrawalDetailUser.innerHTML = userDisplay; elements.withdrawalDetailUserUid.textContent = userId || 'N/A'; elements.withdrawalDetailAmount.textContent = (w.amount || 0).toFixed(2); elements.withdrawalDetailMethod.textContent = methodDisplay; if (type === 'reject') { elements.withdrawalRejectReasonDiv.style.display = 'block'; elements.withdrawalRejectReasonInput.required = true; elements.approveWithdrawalBtn.style.display = 'none'; } else { elements.withdrawalApproveNoteDiv.style.display = 'block'; elements.rejectWithdrawalBtn.style.display = 'none'; } getModalInstance(elements.withdrawalActionModalEl)?.show(); } catch (error) { alert(`Error: ${error.message}`); showStatus(elements.withdrawalsStatus, `Error: ${error.message}`, 'danger', false); } finally { showLoader(false); } }
        async function processWithdrawalAction() { if (!db || !currentWithdrawalAction.id || !currentWithdrawalAction.type || !currentWithdrawalAction.userId) { showStatus(elements.withdrawalActionStatus, "Internal error.", "danger", false); return; } const statusEl = elements.withdrawalActionStatus; clearStatus(statusEl); const withdrawalId = currentWithdrawalAction.id; const actionType = currentWithdrawalAction.type; const userId = currentWithdrawalAction.userId; const amountToProcess = currentWithdrawalAction.amount; const updates = {}; const withdrawalRefPath = `withdrawals/${withdrawalId}`; let reason = ''; let adminNote = ''; let logType = ''; let logStatus = 'failed'; let refundRequired = false; showLoader(true); elements.approveWithdrawalBtn.disabled = true; elements.rejectWithdrawalBtn.disabled = true; try { const wSnapshot = await get(ref(db, withdrawalRefPath)); if (!wSnapshot.exists()) throw new Error("Withdrawal request not found."); const wData = wSnapshot.val(); if (wData.status !== 'pending') throw new Error(`Request already processed (Status: ${wData.status}).`); if (amountToProcess <= 0) throw new Error("Invalid amount for withdrawal."); if (actionType === 'reject') { reason = elements.withdrawalRejectReasonInput.value.trim(); if (!reason) { elements.rejectWithdrawalBtn.disabled = false; throw new Error("Rejection reason required."); } updates[`${withdrawalRefPath}/status`] = 'rejected'; updates[`${withdrawalRefPath}/rejectReason`] = reason; updates[`${withdrawalRefPath}/processedAt`] = serverTimestamp(); updates[`${withdrawalRefPath}/processedBy`] = currentAdminUser.uid; refundRequired = true; logType = 'withdrawal_rejected'; logStatus = 'completed'; } else { adminNote = elements.withdrawalApproveNoteInput.value.trim(); updates[`${withdrawalRefPath}/status`] = 'completed'; updates[`${withdrawalRefPath}/adminNote`] = adminNote || 'Approved'; updates[`${withdrawalRefPath}/processedAt`] = serverTimestamp(); updates[`${withdrawalRefPath}/processedBy`] = currentAdminUser.uid; refundRequired = false; logType = 'withdrawal_approved'; logStatus = 'completed'; const userRefPath = `users/${userId}`; const uSnapshot = await get(ref(db, userRefPath)); if (!uSnapshot.exists()) throw new Error(`User ${userId} not found for balance deduction.`); const user = uSnapshot.val(); const currentBalance = Number(user.balance || 0); const currentWinningCash = Number(user.winningCash || 0); let newBalance = currentBalance; let newWinningCash = currentWinningCash; if (currentWinningCash < amountToProcess) { throw new Error(`Cannot complete: User's winning cash (PKR ${currentWinningCash.toFixed(2)}) is less than withdrawal amount (PKR ${amountToProcess.toFixed(2)}). Adjust balances or reject.`); } newBalance -= amountToProcess; newWinningCash -= amountToProcess; if (newBalance < 0) { throw new Error(`User's total balance would go negative. Winning cash: ${formatCurrency(currentWinningCash)}, Total: ${formatCurrency(currentBalance)}`); } updates[`${userRefPath}/balance`] = newBalance; updates[`${userRefPath}/winningCash`] = newWinningCash; if (fullUserDataCache[userId]) { fullUserDataCache[userId].balance = newBalance; fullUserDataCache[userId].winningCash = newWinningCash;} if (userDataCache[userId]) {userDataCache[userId].balance = newBalance; userDataCache[userId].winningCash = newWinningCash;} } if (refundRequired) { const uSnapshot = await get(ref(db, `users/${userId}`)); if (!uSnapshot.exists()) throw new Error(`User ${userId} not found for refund (this should not happen if initial withdrawal was valid).`); const user = uSnapshot.val(); const currentWinning = Number(user.winningCash || 0); const newWinning = currentWinning + amountToProcess; updates[`users/${userId}/winningCash`] = newWinning; const refundTxKey = push(ref(db, `transactions/${userId}`)).key; updates[`transactions/${userId}/${refundTxKey}`] = { type: 'withdrawal_refund', amount: amountToProcess, timestamp: serverTimestamp(), description: `Refund rejected withdrawal: ${withdrawalId}. Reason: ${reason}`, status: 'completed', adminUid: currentAdminUser.uid }; if (fullUserDataCache[userId]) fullUserDataCache[userId].winningCash = newWinning; if (userDataCache[userId]) userDataCache[userId].winningCash = newWinning; } const mainTxKey = push(ref(db, `transactions/${userId}`)).key; updates[`transactions/${userId}/${mainTxKey}`] = { type: logType, amount: -amountToProcess, timestamp: serverTimestamp(), description: `Withdrawal ${actionType} by admin. ID: ${withdrawalId}. ${actionType === 'reject' ? `Reason: ${reason}` : `Note: ${adminNote}`}`, status: logStatus, withdrawalId: withdrawalId, adminUid: currentAdminUser.uid }; await update(ref(db), updates); showStatus(elements.withdrawalsStatus, `Withdrawal ${actionType} successfully!`, "success", 4000); getModalInstance(elements.withdrawalActionModalEl)?.hide(); loadDashboardStats(); loadWithdrawals(actionType === 'reject' ? 'rejected' : 'completed'); loadWithdrawals('pending'); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); } finally { showLoader(false); if (getModalInstance(elements.withdrawalActionModalEl)?._isShown) { elements.approveWithdrawalBtn.disabled = false; elements.rejectWithdrawalBtn.disabled = false; } } }
        async function saveSettings(event) { event.preventDefault(); if (!db) return; const statusEl = elements.settingsStatus; clearStatus(statusEl); try { const minW = parseFloat(elements.settingMinWithdrawInput.value) || 0; const refB = parseFloat(elements.settingReferralBonusInput.value) || 0; const newUserB = parseFloat(elements.settingNewUserBonusInput.value) || 0; const newUserC = parseInt(elements.settingNewUserGameCoinsInput.value) || 0; if (minW < 0 || refB < 0 || newUserB < 0 || newUserC < 0) { throw new Error("Numeric values cannot be negative."); } const dailyRewards = elements.settingDailyCheckinRewardsInput.value.trim().split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n) && n >= 0); const settingsData = { logoUrl: elements.settingLogoUrlInput.value.trim(), appName: elements.settingAppNameInput.value.trim(), minWithdraw: minW, referralBonus: refB, newUserBonus: newUserB, supportContact: elements.settingSupportContactInput.value.trim(), paymentAccountDetails: elements.settingPaymentAccountDetailsInput.value.trim(), policyPrivacy: elements.settingPolicyPrivacyInput.value.trim(), policyTerms: elements.settingPolicyTermsInput.value.trim(), policyRefund: elements.settingPolicyRefundInput.value.trim(), policyFairPlay: elements.settingPolicyFairPlayInput.value.trim(), dailyCheckinRewards: dailyRewards, lastUpdated: serverTimestamp() }; showLoader(true); elements.appSettingsForm?.querySelectorAll('input, textarea, button').forEach(el => el.disabled = true); await update(ref(db, 'settings'), settingsData); const gameCoinUpdates = {}; gameCoinUpdates[`settings/gameCoinOptions/newUserGameCoins`] = newUserC; await update(ref(db), gameCoinUpdates); appSettings = {...appSettings, ...settingsData, gameCoinOptions: {...appSettings.gameCoinOptions, newUserGameCoins: newUserC}}; showStatus(statusEl, "Settings saved!", "success", 3000); if(elements.adminHeaderLogo) { const logoUrl = appSettings.logoUrl; elements.adminHeaderLogo.src = logoUrl || 'https://via.placeholder.com/35/1E293B/94A3B8?text=L'; elements.adminHeaderLogo.style.display = logoUrl ? 'inline-block' : 'none'; elements.adminHeaderLogo.alt = appSettings.appName ? `${appSettings.appName} Logo` : 'Logo'; } document.title = `${appSettings.appName || 'Gaming Tournament'} - Admin Panel`; } catch (error) { showStatus(statusEl, `Error saving settings: ${error.message}.`, "danger", false); } finally { showLoader(false); elements.appSettingsForm?.querySelectorAll('input, textarea, button').forEach(el => el.disabled = false); } }
        async function addDemoData() { if (!db || !confirm("Add sample demo data? This will only add data if specific collections are empty.")) return; showLoader(true); elements.addDemoDataBtn.disabled = true; const sectionEl = querySel('#adminMainContent .section.active'); const statusEl = sectionEl?.querySelector('div[id$="Status"]') || elements.dashboardStatus; clearStatus(statusEl); let added = []; const now = Date.now(); const demoAdminUid = currentAdminUser ? currentAdminUser.uid : "demo_admin_uid"; try { const gamesRef = ref(db, 'games'); const gamesSnap = await get(gamesRef); let demoGameId = null; if (!gamesSnap.exists() || gamesSnap.size === 0) { const newRef = push(gamesRef); demoGameId = newRef.key; await set(newRef, { name: "Demo Game (PK)", imageUrl: "https://i.ibb.co/4Z5hPVzp/20250418-150058.jpg", createdAt: serverTimestamp() }); added.push("Game"); gameDataCache[demoGameId] = "Demo Game (PK)"; } else { const games = gamesSnap.val(); demoGameId = Object.keys(games)[0]; gameDataCache = Object.entries(games).reduce((acc, [id, data]) => { acc[id] = data.name; return acc; }, {}); } const promoRef = ref(db, 'promotions'); const promoSnap = await get(promoRef); if (!promoSnap.exists() || promoSnap.size === 0) { await set(push(promoRef), { imageUrl: "https://i.ibb.co/RGmQ420n/20250418-150709.jpg", link: "#", createdAt: serverTimestamp() }); added.push("Promotion"); } if (demoGameId) { const tRef = ref(db, 'tournaments'); const tSnap = await get(tRef); if (!tSnap.exists() || tSnap.size === 0) { await set(push(tRef), { gameId: demoGameId, name: "Weekend Demo PK", startTime: now + 86400000, status: "upcoming", entryFee: 100, prizePool: 1000, perKillPrize: 20, maxPlayers: 50, tags: ["Demo", "Squad"], description: "Sample PK tournament.", createdAt: serverTimestamp(), updatedAt: serverTimestamp() }); added.push("Tournament"); } } const usersRef = ref(db, 'users'); let usersExist = false; const usersSnap = await get(usersRef); if(usersSnap.exists() && usersSnap.size > 1) usersExist = true; if(!usersExist && auth && designatedAdminUid) { try { const demoEmail = `demo${Date.now().toString().slice(-5)}@example.com`, demoPass = "password"; if (auth.currentUser?.uid !== designatedAdminUid) { console.warn("Demo user creation skipped as current auth user is not the designated admin, to prevent accidental auth state changes."); } else { const cred = await createUserWithEmailAndPassword(auth, demoEmail, demoPass); const uid = cred.user.uid; const code = Math.random().toString(36).substring(2, 10).toUpperCase(); await set(ref(db, `users/${uid}`), { uid: uid, email: demoEmail, displayName: "Demo Player PK", balance: 500, winningCash: 100, bonusCash: 50, status: 'active', createdAt: serverTimestamp(), referralCode: code, isAdmin: false }); added.push("User (Demo)"); console.log("Demo user created. IMPORTANT: You might be logged in as this demo user now. Please log out and log back in as admin."); } } catch (userErr) { console.error("Error creating demo user:", userErr); } } const settingsRef = ref(db, 'settings'); const settingsSnap = await get(settingsRef); if (!settingsSnap.exists()) { const demoSettings = { appName: "PK Gaming App", logoUrl: "https://i.ibb.co/BvH3m14/Chat-GPT-Image-Apr-18-2025-05-54-04-PM.png", minWithdraw: 500, referralBonus: 50, supportContact: "support@pkdemo.com", paymentAccountDetails: "EasyPaisa: 03139071038 (Admin Name)", policyPrivacy: "Demo PK Privacy Policy.", policyTerms: "Demo PK Terms.", policyRefund: "Demo PK Refund Policy.", policyFairPlay: "Demo PK Fair Play Policy.", lastUpdated: serverTimestamp() }; await set(settingsRef, demoSettings); added.push("Settings"); appSettings = demoSettings; } if (added.length > 0) { showStatus(statusEl, `Demo data added for: ${added.join(', ')}. Refreshing...`, "success", 5000); if (added.includes("Game")) await loadGames(); if (added.includes("Promotion")) await loadPromotions(); if (added.includes("Tournament")) await loadTournaments(); if (added.includes("Settings")) await loadSettings(); if (added.includes("User (Demo)")) await loadUsers(); loadDashboardStats(); } else { showStatus(statusEl, "No demo data added (collections might not be empty).", "info", 5000); } } catch (error) { showStatus(statusEl, `Error adding demo data: ${error.message}.`, "danger", false); } finally { showLoader(false); elements.addDemoDataBtn.disabled = false; } }

        function setupRealtimeAdminListeners() {
            if (!db) return;
            console.log("Setting up realtime count listeners...");
            detachAllAdminListeners();

            const createCountListener = (path, status, badgeEl, statEl, indexOnField = 'status') => {
                const queryRef = query(ref(db, path), orderByChild(indexOnField), equalTo(status));
                const listenerKey = `${path}_${status}_count`;
                dbListeners[listenerKey] = onValue(queryRef, (snapshot) => {
                    const count = snapshot.exists() ? snapshot.size : 0;
                    console.log(`Realtime count for ${listenerKey}:`, count);
                    if (badgeEl) { badgeEl.textContent = count; badgeEl.style.display = count > 0 ? 'inline-block' : 'none'; }
                    if (statEl && elements.dashboardSection?.classList.contains('active')) { statEl.textContent = count; }
                }, error => {
                    console.error(`Error listening to ${listenerKey}:`, error);
                    if (badgeEl) { badgeEl.textContent = 'Err'; badgeEl.style.display = 'inline-block'; }
                    if (statEl && elements.dashboardSection?.classList.contains('active')) statEl.textContent = 'Error';
                    if (error?.message?.includes("index")) showStatus(elements.dashboardStatus, `Count error for ${path}. Add '.indexOn': '${indexOnField}' to rules.`, "danger", false);
                });
                console.log(`Attached listener for ${listenerKey}`);
            };

            createCountListener('withdrawals', 'pending', elements.pendingWithdrawalCountBadge, elements.statPendingWithdrawals);
            createCountListener('diamondRedemptionRequests', 'pending_fulfillment', elements.pendingDiamondCountBadge, elements.statPendingDiamonds);
            
            const depositRequestsRef = ref(db, 'depositRequests');
            const depositListenerKey = 'depositRequests_pending_count';
            dbListeners[depositListenerKey] = onValue(depositRequestsRef, (snapshot) => {
                let count = 0;
                if (snapshot.exists()) {
                    snapshot.forEach(req => {
                        if (req.val()?.status === 'pending_verification') count++;
                    });
                }
                console.log(`Realtime pending deposits count:`, count);
                if (elements.pendingDepositCountBadge) {
                    elements.pendingDepositCountBadge.textContent = count;
                    elements.pendingDepositCountBadge.style.display = count > 0 ? 'inline-block' : 'none';
                }
                if (elements.statPendingDeposits && elements.dashboardSection?.classList.contains('active')) {
                    elements.statPendingDeposits.textContent = count;
                }
            }, error => {
                console.error(`Error listening to deposit requests:`, error);
                if (elements.pendingDepositCountBadge) { elements.pendingDepositCountBadge.textContent = 'Err'; elements.pendingDepositCountBadge.style.display = 'inline-block'; }
                if (elements.statPendingDeposits && elements.dashboardSection?.classList.contains('active')) elements.statPendingDeposits.textContent = 'Error';
            });
            console.log(`Attached listener for ${depositListenerKey}`);
        }

        function detachAllAdminListeners() {
            if (!db || Object.keys(dbListeners).length === 0) return;
            console.log("Detaching all admin listeners...", Object.keys(dbListeners));
            Object.entries(dbListeners).forEach(([key, listenerFunc]) => {
                try {
                    let pathParts = key.split('_'); // e.g., 'withdrawals_pending_count'
                    let targetPath = pathParts[0];
                    let status = pathParts[1];
                    let indexOnField = 'status';

                    let targetRef;
                     if(key === 'users') {
                        targetRef = ref(db, 'users');
                     } else if (key === 'depositRequests_pending_count') {
                        targetRef = ref(db, 'depositRequests');
                     } else if (key.endsWith('_count')) {
                        targetRef = query(ref(db, targetPath), orderByChild(indexOnField), equalTo(status));
                     } else if (key.startsWith('withdrawals-') || key.startsWith('diamondRedemptionRequests-')) {
                        let path = key.split('-')[0];
                        let stat = key.split('-')[1];
                        targetRef = query(ref(db, path), orderByChild('status'), equalTo(stat));
                     } else if (key.startsWith('depositRequests-')) {
                         targetRef = ref(db, 'depositRequests');
                    }
                     else {
                        console.warn("Unknown listener key to detach:", key);
                        return;
                    }
                    if (targetRef && listenerFunc) {
                        off(targetRef, 'value', listenerFunc);
                        console.log("Detached listener for:", key);
                    }
                } catch (e) {
                    console.error("Error detaching listener for key:", key, e);
                }
            });
            dbListeners = {};
        }
        async function openEditGameModal(gameId) { if (!db || !gameId) return; showLoader(true); elements.gameForm.reset(); clearStatus(elements.gameStatus); const imgbbStatusEl = elements.gameForm.querySelector('.imgbb-upload-status'); if (imgbbStatusEl) { imgbbStatusEl.textContent = ''; imgbbStatusEl.style.display = 'none'; } try { const snapshot = await get(ref(db, `games/${gameId}`)); if (!snapshot.exists()) throw new Error(`Game ${gameId} not found.`); const game = snapshot.val(); elements.gameModalTitle.textContent = "Edit Esport Game"; elements.gameEditId.value = gameId; elements.gameNameInput.value = game.name || ''; elements.gameImageUrlInput.value = game.imageUrl || ''; elements.gameImageFileInput.value = ''; getModalInstance(elements.gameModalEl)?.show(); } catch (error) { showStatus(elements.gamesStatus, `Error: ${error.message}`, "danger", false); } finally { showLoader(false); } }
        async function openEditPromotionModal(promoId) { if (!db || !promoId) return; showLoader(true); elements.promotionForm.reset(); clearStatus(elements.promotionStatus); const imgbbStatusEl = elements.promotionForm.querySelector('.imgbb-upload-status'); if (imgbbStatusEl) { imgbbStatusEl.textContent = ''; imgbbStatusEl.style.display = 'none'; } try { const snapshot = await get(ref(db, `promotions/${promoId}`)); if (!snapshot.exists()) throw new Error(`Promotion ${promoId} not found.`); const promo = snapshot.val(); elements.promotionModalTitle.textContent = "Edit Promotion"; elements.promotionEditId.value = promoId; elements.promoImageUrlInput.value = promo.imageUrl || ''; elements.promoLinkInput.value = promo.link || ''; elements.promoImageFileInput.value = ''; getModalInstance(elements.promotionModalEl)?.show(); } catch (error) { showStatus(elements.promotionsStatus, `Error: ${error.message}`, "danger", false); } finally { showLoader(false); } }
        async function populateGameSelect(selectedValue = null) { if (!elements.tournamentGameSelect) return; const select = elements.tournamentGameSelect; select.innerHTML = '<option value="">Loading...</option>'; select.disabled = true; try { if (Object.keys(gameDataCache).length === 0) await loadGames(); if (Object.keys(gameDataCache).length > 0) { select.innerHTML = '<option value="">-- Select Game --</option>'; const sorted = Object.entries(gameDataCache).sort(([, a], [, b]) => a.localeCompare(b)); sorted.forEach(([id, name]) => { const opt = document.createElement('option'); opt.value = id; opt.textContent = sanitizeHTML(name); select.appendChild(opt); }); if (selectedValue) select.value = selectedValue; } else { select.innerHTML = '<option value="">No Games Available</option>'; } } catch (error) { select.innerHTML = '<option value="">Error Loading</option>'; } finally { select.disabled = false; } }
        async function openEditTournamentModal(tournamentId) { if (!db || !tournamentId) return; showLoader(true); clearStatus(elements.addTournamentStatus); elements.tournamentForm.reset(); currentEditingTournamentId = tournamentId; try { const snapshot = await get(ref(db, `tournaments/${tournamentId}`)); if (!snapshot.exists()) throw new Error(`Tournament ${tournamentId} not found.`); const t = snapshot.val(); await populateGameSelect(t.gameId); elements.tournamentModalTitle.textContent = "Edit Tournament"; elements.tournamentEditId.value = tournamentId; elements.tournamentNameInput.value = t.name || ''; if (t.startTime) { try { const d = new Date(t.startTime); if (!isNaN(d)) { const offset = d.getTimezoneOffset() * 60000; elements.tournamentStartTimeInput.value = new Date(d - offset).toISOString().slice(0, 16); } } catch(e){} } elements.tournamentStatusSelect.value = t.status || 'upcoming'; elements.tournamentEntryFeeInput.value = t.entryFee ?? 0; elements.tournamentEntryFeeCoinsInput.value = t.entryFeeCoins ?? 0; elements.tournamentPrizePoolInput.value = t.prizePool ?? 0; elements.tournamentPrizePoolCoinsInput.value = t.prizePoolCoins ?? 0; elements.tournamentPerKillInput.value = t.perKillPrize ?? 0; elements.tournamentPerKillCoinsInput.value = t.perKillPrizeCoins ?? 0; elements.tournamentMaxPlayersInput.value = t.maxPlayers ?? 0; elements.tournamentTagsInput.value = (t.tags || []).join(', '); elements.tournamentDescriptionInput.value = t.description || ''; elements.tournamentRoomIdInput.value = t.roomId || ''; elements.tournamentRoomPasswordInput.value = t.roomPassword || ''; elements.tournamentShowIdPassCheckbox.checked = t.showIdPass || false; getModalInstance(elements.addTournamentModalEl)?.show(); } catch (error) { showStatus(elements.tournamentsStatus, `Error: ${error.message}`, "danger", false); currentEditingTournamentId = null; } finally { showLoader(false); } }
        
        async function openUserModal(userId) {
            if (!db || !userId) return;
            showLoader(true);
            clearStatus(elements.balanceUpdateStatus);
            elements.updateBalanceForm.reset();
            elements.userDetailReferredBy.textContent = "N/A";
            elements.userDetailReferredCount.textContent = "...";
            elements.userDetailGameUid.textContent = 'N/A';
            elements.userDetailVerificationStatus.innerHTML = '...';

            try {
                let user;
                if (fullUserDataCache[userId]) {
                    user = fullUserDataCache[userId];
                } else {
                    const snapshot = await get(ref(db, `users/${userId}`));
                    if (!snapshot.exists()) throw new Error(`User ${userId} not found.`);
                    user = snapshot.val();
                    user.uid = userId;
                    fullUserDataCache[userId] = user;
                }
                const isVerified = authUserCache[userId]?.emailVerified || false;
                
                elements.userModalTitle.textContent = `User: ${sanitizeHTML(user.displayName || 'N/A')}`;
                elements.userDetailUid.textContent = userId;
                elements.userDetailUid.nextElementSibling.dataset.targetText = userId;
                elements.userDetailGameUid.textContent = sanitizeHTML(user.gameUid || 'N/A');
                elements.userDetailGameUid.nextElementSibling.dataset.targetText = user.gameUid || '';
                elements.userDetailEmail.textContent = sanitizeHTML(user.email || 'N/A');
                elements.userDetailVerificationStatus.innerHTML = isVerified ? `<span class="badge text-bg-success">Verified</span>` : `<span class="badge text-bg-warning">Not Verified</span>`;
                elements.userDetailName.textContent = sanitizeHTML(user.displayName || 'N/A');
                elements.userDetailCreatedAt.textContent = formatDate(user.createdAt);
                elements.userDetailBalance.textContent = (user.balance || 0).toFixed(2);
                elements.userDetailWinning.textContent = (user.winningCash || 0).toFixed(2);
                elements.userDetailBonus.textContent = (user.bonusCash || 0).toFixed(2);
                elements.userDetailCoins.textContent = (user.gameCoins || 0);
                elements.editUserUid.value = userId;
                elements.userDetailReferralCode.textContent = user.referralCode || 'N/A';
                elements.userDetailReferralCode.nextElementSibling.dataset.targetText = user.referralCode || '';

                if(user.referredBy && fullUserDataCache[user.referredBy]) {
                    elements.userDetailReferredBy.textContent = `${fullUserDataCache[user.referredBy].displayName} (${user.referredBy})`;
                } else if(user.referredBy) {
                    elements.userDetailReferredBy.textContent = `UID: ${user.referredBy}`;
                }

                const status = user.status || 'active';
                elements.userDetailStatus.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                elements.userDetailStatus.className = `fw-bold text-${status === 'active' ? 'success' : 'danger'}`;
                elements.userBlockBtn.textContent = status === 'active' ? 'Block User' : 'Unblock User';
                elements.userBlockBtn.className = `btn btn-sm ${status === 'active' ? 'btn-danger' : 'btn-success'}`;
                elements.userBlockBtn.dataset.id = userId;
                elements.userBlockBtn.dataset.action = status === 'active' ? 'block' : 'unblock';
                elements.userDeleteBtn.dataset.id = userId;

                getModalInstance(elements.userModalEl)?.show();
                
                loadAndDisplayReferralCount(userId);

            } catch (error) {
                showStatus(elements.usersStatus, `Error: ${error.message}`, "danger", false);
            } finally {
                showLoader(false);
            }
        }
        
        async function loadAndDisplayReferralCount(userId) {
            const countEl = elements.userDetailReferredCount;
            if (!db || !userId || !countEl) return;
            countEl.textContent = '...';
            try {
                const q = query(ref(db, 'users'), orderByChild('referredBy'), equalTo(userId));
                const snapshot = await get(q);
                countEl.textContent = snapshot.exists() ? snapshot.size : 0;
            } catch (error) {
                console.error("Error fetching referral count:", error);
                countEl.textContent = 'Error';
            }
        }
        
        async function openRegisteredPlayersModal(tournamentId, tournamentName) { if (!db || !tournamentId) return; elements.registeredPlayersModalTitle.textContent = "Registered Players"; elements.registeredPlayersTournamentName.textContent = tournamentName || "N/A"; elements.registeredPlayersTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3"><div class="spinner-border spinner-border-sm"></div></td></tr>`; clearStatus(elements.registeredPlayersStatus); getModalInstance(elements.registeredPlayersModalEl)?.show(); try { const playersRef = ref(db, `tournaments/${tournamentId}/registeredPlayers`); const snapshot = await get(playersRef); if (!snapshot.exists()) { elements.registeredPlayersTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-muted">No players registered.</td></tr>`; return; } const registeredData = snapshot.val(); const userIds = Object.keys(registeredData); let tableHtml = ''; let fetchedCount = 0; const userFetchPromises = userIds.map(async (uid) => { try { let u = fullUserDataCache[uid]; if (!u) { const uSnap = await get(ref(db, `users/${uid}`)); if (uSnap.exists()) { u = uSnap.val(); u.uid = uid; fullUserDataCache[uid] = u; } else { u = { uid: uid, displayName: 'Not Found', email: 'N/A' }; } } return { user: u, playerData: registeredData[uid] }; } catch (err) { return { user: { uid: uid, displayName: 'Error Fetching User', email: 'N/A' }, playerData: registeredData[uid] }; } }); const results = await Promise.allSettled(userFetchPromises); results.forEach(res => { if (res.status === 'fulfilled' && res.value) { const { user, playerData } = res.value; tableHtml += `<tr> <td><small class="text-muted">${sanitizeHTML(user.uid)}</small></td> <td>${sanitizeHTML(user.displayName)}</td> <td>${sanitizeHTML(user.email)}</td> <td>${sanitizeHTML(playerData?.gameUid || 'N/A')}</td> <td>${formatDate(playerData?.joinedAt)}</td> </tr>`; fetchedCount++; } }); elements.registeredPlayersTableBody.innerHTML = tableHtml || `<tr><td colspan="5" class="text-center p-3 text-muted">Could not load player details.</td></tr>`; elements.registeredPlayersModalTitle.textContent = `Registered Players (${fetchedCount})`; } catch (error) { elements.registeredPlayersTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-danger">Error: ${error.message}.</td></tr>`; showStatus(elements.registeredPlayersStatus, `Error: ${error.message}`, 'danger'); } }
        async function loadWithdrawals(status = 'pending') { if (!db) return; const targetTableBody = getElement(`${status}WithdrawalsTableBody`); if (!targetTableBody) { console.error(`Table body not found for withdrawals: ${status}WithdrawalsTableBody`); return; } const q = query(ref(db, 'withdrawals'), orderByChild('status'), equalTo(status)); targetTableBody.innerHTML = tableLoadingPlaceholderHtml(status === 'pending' ? 6 : 7); if (status === 'pending') clearStatus(elements.withdrawalsStatus); const listenerKey = `withdrawals-${status}`; if (dbListeners[listenerKey]) try { off(q, 'value', dbListeners[listenerKey]); delete dbListeners[listenerKey]; console.log("Detached old listener for:", listenerKey); } catch (e) { console.warn("Error detaching old withdrawals listener:", listenerKey, e); } dbListeners[listenerKey] = onValue(q, async (snapshot) => { let tableHtml = ''; let count = 0; targetTableBody.innerHTML = ''; if (snapshot.exists()) { count = snapshot.size; const userIds = new Set(); snapshot.forEach(child => { if (child.val()?.userId && !userDataCache[child.val().userId]) userIds.add(child.val().userId); }); if (userIds.size > 0) { const promises = Array.from(userIds).map(uid => get(ref(db, `users/${uid}`)).then(us => { if (us.exists()) { const u = us.val(); userDataCache[uid] = { displayName: u.displayName || 'N/A', email: u.email || uid, status: u.status || 'unknown' }; } else { userDataCache[uid] = { displayName: 'Unknown', email: uid, status: 'deleted' }; } }).catch(err => { userDataCache[uid] = { displayName: 'Error', email: uid, status: 'error' }; }) ); await Promise.allSettled(promises); } const withdrawals = []; snapshot.forEach(child => withdrawals.push({ id: child.key, ...child.val() })); withdrawals.sort((a, b) => (b.requestTimestamp || 0) - (a.requestTimestamp || 0)); withdrawals.forEach(w => { if (w && w.userId && w.amount != null && w.requestTimestamp) { const user = userDataCache[w.userId] || { displayName: 'Loading...', email: w.userId, status: 'unknown' }; const userDisplay = `${sanitizeHTML(user.displayName)} (<small class="text-muted" title="${w.userId}">${sanitizeHTML(user.email)}</small>)`; let methodDisplay = sanitizeHTML(w.methodDetails?.methodName || 'N/A'); let accountInfoDisplay = sanitizeHTML(w.methodDetails?.accountInfo || 'N/A'); const requestTime = formatDate(w.requestTimestamp); const processedTime = formatDate(w.processedAt); let rowHtml = `<tr><td>${requestTime}</td>`; if (status !== 'pending') rowHtml += `<td>${processedTime}</td>`; rowHtml += `<td>${userDisplay}</td><td>${formatCurrency(w.amount)}</td><td>${methodDisplay}</td><td>${accountInfoDisplay}</td>`; if (status === 'pending') { rowHtml += `<td class="action-buttons"><button class="btn btn-sm btn-success btn-approve-withdrawal" data-id="${sanitizeHTML(w.id)}" data-userid="${sanitizeHTML(w.userId)}" title="Approve"><i class="bi bi-check-circle"></i></button> <button class="btn btn-sm btn-danger btn-reject-withdrawal" data-id="${sanitizeHTML(w.id)}" data-userid="${sanitizeHTML(w.userId)}" title="Reject"><i class="bi bi-x-circle"></i></button></td>`; } else if (status === 'completed') { const note = sanitizeHTML(w.adminNote || ''); rowHtml += `<td><small title="${note}">${note.substring(0, 30)}${ note.length > 30 ? '...' : ''}</small></td>`; } else if (status === 'rejected') { const reason = sanitizeHTML(w.rejectReason || ''); rowHtml += `<td><small title="${reason}">${reason.substring(0, 30)}${ reason.length > 30 ? '...' : ''}</small></td>`; } rowHtml += `</tr>`; tableHtml += rowHtml; } }); } const emptyColspan = status === 'pending' ? 6 : 7; targetTableBody.innerHTML = tableHtml || `<tr><td colspan="${emptyColspan}" class="text-center p-3 text-muted">No ${status} withdrawals found.</td></tr>`; if (status === 'pending') { if (elements.pendingWithdrawalCountBadge) { elements.pendingWithdrawalCountBadge.textContent = count; elements.pendingWithdrawalCountBadge.style.display = count > 0 ? 'inline-block' : 'none'; } if (elements.dashboardSection?.classList.contains('active') && elements.statPendingWithdrawals) elements.statPendingWithdrawals.textContent = count; } else if (status === 'completed' && elements.dashboardSection?.classList.contains('active') && elements.statCompletedWithdrawals) { elements.statCompletedWithdrawals.textContent = count; } else if (status === 'rejected' && elements.dashboardSection?.classList.contains('active') && elements.statRejectedWithdrawals) { elements.statRejectedWithdrawals.textContent = count; } }, (error) => { const errorColspan = status === 'pending' ? 6 : 7; targetTableBody.innerHTML = `<tr><td colspan="${errorColspan}" class="text-center p-3 text-danger">Error: ${error.message}. Check Rules/Index.</td></tr>`; showStatus(elements.withdrawalsStatus, `Error loading ${status} withdrawals: ${error.message}. Ensure '.indexOn': 'status' rule exists for '/withdrawals'.`, 'danger', false); if (status === 'pending') { if(elements.pendingWithdrawalCountBadge){ elements.pendingWithdrawalCountBadge.textContent = 'Err'; elements.pendingWithdrawalCountBadge.style.display = 'inline-block';} if (elements.dashboardSection?.classList.contains('active') && elements.statPendingWithdrawals) elements.statPendingWithdrawals.textContent = 'Error'; } else if (status === 'completed' && elements.dashboardSection?.classList.contains('active') && elements.statCompletedWithdrawals) elements.statCompletedWithdrawals.textContent = 'Error'; else if (status === 'rejected' && elements.dashboardSection?.classList.contains('active') && elements.statRejectedWithdrawals) elements.statRejectedWithdrawals.textContent = 'Error'; try { if (dbListeners[listenerKey]) { off(q, 'value', dbListeners[listenerKey]); delete dbListeners[listenerKey]; } } catch(e) { console.warn("Error detaching withdrawals listener on error:", listenerKey, e);} }); console.log("Attached listener for:", listenerKey); }
        async function loadDepositRequests(status = 'pending_verification') {
            if (!db) return;
            const targetTableBodyId = status === 'pending_verification' ? 'pending_verificationDepositsTableBody' : `${status}DepositsTableBody`;
            const targetTableBody = getElement(targetTableBodyId);

            if (!targetTableBody) {
                console.error(`Table body not found for deposits: ${targetTableBodyId}`);
                return;
            }

            const depositsRootRef = ref(db, 'depositRequests');
            targetTableBody.innerHTML = tableLoadingPlaceholderHtml(status === 'pending_verification' ? 7 : 8);
            if (status === 'pending_verification') clearStatus(elements.depositRequestsStatus);

            const listenerKey = `depositRequests-${status}`;
            if (dbListeners[listenerKey]) {
                try {
                    off(depositsRootRef, 'value', dbListeners[listenerKey]);
                    delete dbListeners[listenerKey];
                    console.log("Detached old listener for:", listenerKey);
                } catch (e) {
                    console.warn("Error detaching old deposit listener:", listenerKey, e);
                }
            }

            dbListeners[listenerKey] = onValue(depositsRootRef, async (snapshot) => {
                let tableHtml = '';
                let count = 0;
                targetTableBody.innerHTML = '';

                const userIdsToFetch = new Set();
                const filteredRequests = [];

                if (snapshot.exists()) {
                    snapshot.forEach(requestSnapshot => {
                        const req = requestSnapshot.val();
                        if (req && req.status === status) {
                            if (req.userId && !userDataCache[req.userId]) {
                                userIdsToFetch.add(req.userId);
                            }
                            filteredRequests.push({ key: requestSnapshot.key, ...req });
                            count++;
                        }
                    });
                }

                if (userIdsToFetch.size > 0) {
                    const promises = Array.from(userIdsToFetch).map(uid =>
                        get(ref(db, `users/${uid}`)).then(us => {
                            if (us.exists()) {
                                const u = us.val();
                                userDataCache[uid] = { displayName: u.displayName || 'N/A', email: u.email || uid };
                            } else {
                                userDataCache[uid] = { displayName: 'Unknown User', email: uid };
                            }
                        }).catch(err => {
                            console.error(`Error fetching user ${uid}:`, err);
                            userDataCache[uid] = { displayName: 'Error Fetching', email: uid };
                        })
                    );
                    await Promise.allSettled(promises);
                }

                filteredRequests.sort((a, b) => (b.requestTimestamp || 0) - (a.requestTimestamp || 0));

                filteredRequests.forEach(req => {
                    const user = userDataCache[req.userId] || { displayName: 'Loading...', email: req.userId };
                    const userDisplay = `${sanitizeHTML(user.displayName)} (<small class="text-muted" title="${req.userId}">${sanitizeHTML(user.email)}</small>)`;
                    const requestTime = formatDate(req.requestTimestamp);
                    const processedTime = formatDate(req.processedAt);
                    let rowHtml = `<tr><td>${requestTime}</td>`;
                    if (status !== 'pending_verification') rowHtml += `<td>${processedTime}</td>`;
                    rowHtml += `<td>${userDisplay}</td><td>${formatCurrency(req.amount)}</td><td class="wrap-text">${sanitizeHTML(req.transactionId)}</td><td>${sanitizeHTML(req.senderNumber)}</td><td>${sanitizeHTML(req.senderName)}</td>`;

                    if (status === 'pending_verification') {
                        rowHtml += `<td class="action-buttons"><button class="btn btn-sm btn-success btn-approve-deposit" data-req-key="${sanitizeHTML(req.key)}" title="Approve"><i class="bi bi-check-circle"></i></button> <button class="btn btn-sm btn-danger btn-reject-deposit" data-req-key="${sanitizeHTML(req.key)}" title="Reject"><i class="bi bi-x-circle"></i></button></td>`;
                    } else if (status === 'completed') {
                        rowHtml += `<td><small title="${sanitizeHTML(req.adminNote || '')}">${sanitizeHTML(String(req.adminNote || '')).substring(0,30)}</small></td>`;
                    } else if (status === 'rejected') {
                        rowHtml += `<td><small title="${sanitizeHTML(req.rejectReason || '')}">${sanitizeHTML(String(req.rejectReason || '')).substring(0,30)}</small></td>`;
                    }
                    rowHtml += `</tr>`;
                    tableHtml += rowHtml;
                });

                const emptyColspan = status === 'pending_verification' ? 7 : 8;
                targetTableBody.innerHTML = tableHtml || `<tr><td colspan="${emptyColspan}" class="text-center p-3 text-muted">No ${status.replace('_', ' ')} deposit requests.</td></tr>`;

                if (status === 'pending_verification') {
                    if (elements.pendingDepositCountBadge) {
                        elements.pendingDepositCountBadge.textContent = count;
                        elements.pendingDepositCountBadge.style.display = count > 0 ? 'inline-block' : 'none';
                    }
                    if (elements.dashboardSection?.classList.contains('active') && elements.statPendingDeposits) {
                        elements.statPendingDeposits.textContent = count;
                    }
                }
            }, (error) => {
                const errorColspan = status === 'pending_verification' ? 7 : 8;
                targetTableBody.innerHTML = `<tr><td colspan="${errorColspan}" class="text-center p-3 text-danger">Error: ${error.message}. Check Firebase Rules.</td></tr>`;
                showStatus(elements.depositRequestsStatus, `Error loading ${status.replace('_', ' ')} deposits: ${error.message}.`, 'danger', false);

                if (status === 'pending_verification') {
                    if (elements.pendingDepositCountBadge) { elements.pendingDepositCountBadge.textContent = 'Err'; elements.pendingDepositCountBadge.style.display = 'inline-block'; }
                    if (elements.dashboardSection?.classList.contains('active') && elements.statPendingDeposits) elements.statPendingDeposits.textContent = 'Error';
                }
                try { if (dbListeners[listenerKey]) { off(depositsRootRef, 'value', dbListeners[listenerKey]); delete dbListeners[listenerKey]; } } catch(e) { console.warn("Error detaching deposit listener on error:", listenerKey, e); }
            });
            console.log("Attached listener for:", listenerKey);
        }
        async function openDepositActionModal(requestKey, type) { if (!db || !requestKey || !type) return; showLoader(true); const depositReqRef = ref(db, `depositRequests/${requestKey}`); currentDepositAction = { id: requestKey, type: type, userId: null, amount: 0, requestKey: requestKey }; elements.depositRejectReasonInput.value = ''; elements.depositApproveNoteInput.value = ''; elements.depositRejectReasonDiv.style.display = 'none'; elements.depositApproveNoteDiv.style.display = 'none'; elements.depositRejectReasonInput.required = false; elements.depositApproveNoteInput.required = false; clearStatus(elements.depositActionStatus); elements.approveDepositBtn.style.display = 'inline-block'; elements.rejectDepositBtn.style.display = 'inline-block'; elements.approveDepositBtn.disabled = false; elements.rejectDepositBtn.disabled = false; try { const snapshot = await get(depositReqRef); if (!snapshot.exists()) throw new Error(`Deposit request ${requestKey} not found.`); const req = snapshot.val(); currentDepositAction.userId = req.userId; currentDepositAction.amount = Number(req.amount || 0); if (req.status !== 'pending_verification') { alert(`Request already processed (Status: ${req.status}).`); showLoader(false); return; } let userDisplay = `UID: ${req.userId}`; if (req.userId && userDataCache[req.userId]) { const u = userDataCache[req.userId]; userDisplay = `${sanitizeHTML(u.displayName)} (<small class="text-muted" title="${req.userId}">${sanitizeHTML(u.email)}</small>)`; } else if (req.userId) { try { const userSnap = await get(ref(db, `users/${req.userId}`)); if (userSnap.exists()) { const u = userSnap.val(); userDataCache[req.userId] = { displayName: u.displayName || 'N/A', email: u.email || req.userId }; userDisplay = `${sanitizeHTML(u.displayName)} (<small class="text-muted" title="${req.userId}">${sanitizeHTML(u.email)}</small>)`; } else { userDisplay = `Unknown User (<small class="text-muted" title="${req.userId}">${req.userId}</small>)`;} } catch (e) { userDisplay = `Error User (<small class="text-muted" title="${req.userId}">${req.userId}</small>)`; } } elements.depositDetailId.textContent = requestKey; elements.depositDetailUser.innerHTML = userDisplay; elements.depositDetailUserUid.textContent = req.userId || 'N/A'; elements.depositDetailAmount.textContent = (req.amount || 0).toFixed(2); elements.depositDetailTxnId.textContent = sanitizeHTML(req.transactionId); elements.depositDetailSenderNumber.textContent = sanitizeHTML(req.senderNumber); elements.depositDetailSenderName.textContent = sanitizeHTML(req.senderName); if (type === 'reject') { elements.depositRejectReasonDiv.style.display = 'block'; elements.depositRejectReasonInput.required = true; elements.approveDepositBtn.style.display = 'none'; } else { elements.depositApproveNoteDiv.style.display = 'block'; elements.rejectDepositBtn.style.display = 'none'; } getModalInstance(elements.depositActionModalEl)?.show(); } catch (error) { alert(`Error: ${error.message}`); showStatus(elements.depositRequestsStatus, `Error: ${error.message}`, 'danger', false); } finally { showLoader(false); } }
        async function processDepositAction() { if (!db || !currentDepositAction.id || !currentDepositAction.type || !currentDepositAction.userId) { showStatus(elements.depositActionStatus, "Internal error.", "danger", false); return; } const statusEl = elements.depositActionStatus; clearStatus(statusEl); const requestKey = currentDepositAction.id; const actionType = currentDepositAction.type; const userId = currentDepositAction.userId; const amount = currentDepositAction.amount; const updates = {}; const depositReqRefPath = `depositRequests/${requestKey}`; let reason = ''; let adminNote = ''; let logType = ''; showLoader(true); elements.approveDepositBtn.disabled = true; elements.rejectDepositBtn.disabled = true; try { const reqSnapshot = await get(ref(db, depositReqRefPath)); if (!reqSnapshot.exists()) throw new Error("Deposit request not found."); const reqData = reqSnapshot.val(); if (reqData.status !== 'pending_verification') throw new Error(`Request already processed (Status: ${reqData.status}).`); if (actionType === 'reject') { reason = elements.depositRejectReasonInput.value.trim(); if (!reason) { elements.rejectDepositBtn.disabled = false; throw new Error("Rejection reason required."); } updates[`${depositReqRefPath}/status`] = 'rejected'; updates[`${depositReqRefPath}/rejectReason`] = reason; updates[`${depositReqRefPath}/processedAt`] = serverTimestamp(); updates[`${depositReqRefPath}/processedBy`] = currentAdminUser.uid; logType = 'deposit_rejected'; } else { adminNote = elements.depositApproveNoteInput.value.trim(); updates[`${depositReqRefPath}/status`] = 'completed'; updates[`${depositReqRefPath}/adminNote`] = adminNote || 'Approved by Admin'; updates[`${depositReqRefPath}/processedAt`] = serverTimestamp(); updates[`${depositReqRefPath}/processedBy`] = currentAdminUser.uid; logType = 'deposit_approved'; const userBalanceRefPath = `users/${userId}/balance`; const userSnap = await get(ref(db, `users/${userId}`)); if (!userSnap.exists()) throw new Error("User not found for balance update."); const newBalance = (userSnap.val().balance || 0) + amount; updates[userBalanceRefPath] = newBalance; const txDescUser = `Deposit Approved (Admin): ${requestKey}. Note: ${adminNote || 'N/A'}`; updates[`transactions/${userId}/${push(ref(db, `transactions/${userId}`)).key}`] = { type: 'deposit_credit', amount: amount, timestamp: serverTimestamp(), description: txDescUser, status: 'completed', balanceAfter: newBalance, adminUid: currentAdminUser.uid, depositRequestId: requestKey }; if (fullUserDataCache[userId]) fullUserDataCache[userId].balance = newBalance; if (userDataCache[userId]) userDataCache[userId].balance = newBalance; } const mainTxKey = push(ref(db, `transactions/${userId}`)).key; updates[`transactions/${userId}/${mainTxKey}`] = { type: logType, amount: (actionType === 'approve' ? amount : 0), timestamp: serverTimestamp(), description: `Deposit request ${actionType} by admin. ID: ${requestKey}. ${actionType === 'reject' ? `Reason: ${reason}` : `Note: ${adminNote}`}`, status: 'completed', depositRequestId: requestKey, adminUid: currentAdminUser.uid }; await update(ref(db), updates); showStatus(elements.depositRequestsStatus, `Deposit request ${actionType} successfully! User balance updated if approved.`, "success", 4000); getModalInstance(elements.depositActionModalEl)?.hide(); loadDashboardStats(); loadDepositRequests(actionType === 'reject' ? 'rejected' : 'completed'); loadDepositRequests('pending_verification'); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); } finally { showLoader(false); if (getModalInstance(elements.depositActionModalEl)?._isShown) { elements.approveDepositBtn.disabled = false; elements.rejectDepositBtn.disabled = false; } } }
        
        async function fetchUserTransactions() {
            if (!db) return;
            const searchTerm = elements.transactionUserSearchInput.value.trim();
            if (!searchTerm) {
                showStatus(elements.transactionsStatus, "Please enter a search term.", "warning");
                return;
            }
            clearStatus(elements.transactionsStatus);
            elements.userTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3"><div class="spinner-border spinner-border-sm"></div> Searching user...</td></tr>`;
            elements.userCoinTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-muted">...</td></tr>`;
            showLoader(true);
            let targetUserId = null;

            try {
                const userSnapDirect = await get(ref(db, `users/${searchTerm}`));
                if (userSnapDirect.exists()) {
                    targetUserId = searchTerm;
                }

                if (!targetUserId) {
                    const emailQuery = query(ref(db, 'users'), orderByChild('email'), equalTo(searchTerm));
                    const emailSnap = await get(emailQuery);
                    if (emailSnap.exists()) {
                        targetUserId = Object.keys(emailSnap.val())[0];
                    }
                }
                
                if (!targetUserId) {
                    const gameUidQuery = query(ref(db, 'users'), orderByChild('gameUid'), equalTo(searchTerm));
                    const gameUidSnap = await get(gameUidQuery);
                    if (gameUidSnap.exists()) {
                        targetUserId = Object.keys(gameUidSnap.val())[0];
                    }
                }
                
                if (!targetUserId) {
                    const nameQuery = query(ref(db, 'users'), orderByChild('displayName'), equalTo(searchTerm));
                    const nameSnap = await get(nameQuery);
                    if (nameSnap.exists()) {
                        targetUserId = Object.keys(nameSnap.val())[0];
                    }
                }

            } catch (e) {
                console.error("Error searching user for transactions:", e);
                showStatus(elements.transactionsStatus, `Error finding user: ${e.message}. Ensure indexes are set for 'email', 'displayName', and 'gameUid'.`, "warning");
                elements.userTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-muted">Error finding user.</td></tr>`;
                showLoader(false);
                return;
            }

            if (!targetUserId) {
                showStatus(elements.transactionsStatus, `User not found for: ${sanitizeHTML(searchTerm)}`, "warning");
                elements.userTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-muted">User not found.</td></tr>`;
                showLoader(false);
                return;
            }

            elements.userTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3"><div class="spinner-border spinner-border-sm"></div> Fetching PKR transactions...</td></tr>`;
            elements.userCoinTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3"><div class="spinner-border spinner-border-sm"></div> Fetching Coin transactions...</td></tr>`;

            try {
                const [pkrSnapshot, coinSnapshot] = await Promise.all([
                    get(query(ref(db, `transactions/${targetUserId}`), orderByChild('timestamp'))),
                    get(query(ref(db, `coinTransactions/${targetUserId}`), orderByChild('timestamp')))
                ]);

                let pkrTableHtml = '';
                if (pkrSnapshot.exists()) {
                    const transactions = []; pkrSnapshot.forEach(child => transactions.push(child.val()));
                    transactions.sort((a,b) => (b.timestamp || 0) - (a.timestamp || 0));
                    transactions.forEach(tx => {
                        const details = tx.withdrawalId ? `Withdrawal ID: ${tx.withdrawalId}` : (tx.tournamentId ? `Tourney ID: ${tx.tournamentId}` : (tx.depositRequestId ? `Deposit ID: ${tx.depositRequestId}` : 'N/A'));
                        pkrTableHtml += `<tr><td>${formatDate(tx.timestamp)}</td><td><span class="status-badge text-bg-${tx.amount > 0 ? 'success' : (tx.amount < 0 ? 'danger' : 'secondary')}">${sanitizeHTML(tx.type)}</span></td><td>${formatCurrency(tx.amount)}</td><td class="wrap-text">${sanitizeHTML(tx.description)}</td><td><small class="text-muted">${sanitizeHTML(details)}</small></td></tr>`;
                    });
                    elements.userTransactionsTableBody.innerHTML = pkrTableHtml;
                } else {
                    elements.userTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-muted">No PKR transactions found.</td></tr>`;
                }

                let coinTableHtml = '';
                if (coinSnapshot.exists()) {
                    const transactions = []; coinSnapshot.forEach(child => transactions.push(child.val()));
                    transactions.sort((a,b) => (b.timestamp || 0) - (a.timestamp || 0));
                    transactions.forEach(tx => {
                        const details = tx.requestId ? `Request ID: ${tx.requestId}` : (tx.tournamentId ? `Tourney ID: ${tx.tournamentId}` : 'N/A');
                        coinTableHtml += `<tr><td>${formatDate(tx.timestamp)}</td><td><span class="status-badge text-bg-${tx.amount > 0 ? 'success' : (tx.amount < 0 ? 'danger' : 'secondary')}">${sanitizeHTML(tx.type)}</span></td><td><span class="text-coin">${formatCoins(tx.amount)}</span></td><td class="wrap-text">${sanitizeHTML(tx.description)}</td><td><small class="text-muted">${sanitizeHTML(details)}</small></td></tr>`;
                    });
                    elements.userCoinTransactionsTableBody.innerHTML = coinTableHtml;
                } else {
                    elements.userCoinTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-muted">No Coin transactions found.</td></tr>`;
                }
                showStatus(elements.transactionsStatus, `Displaying transactions for user: ${targetUserId}`, "success", 4000);
            } catch (error) {
                elements.userTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-danger">Error: ${error.message}</td></tr>`;
                elements.userCoinTransactionsTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-3 text-danger">Error: ${error.message}</td></tr>`;
                showStatus(elements.transactionsStatus, `Error fetching transactions: ${error.message}. Ensure '.indexOn': 'timestamp' rule for transaction paths.`, "danger");
            } finally {
                showLoader(false);
            }
        }


        // --- Tournament Results Functions ---
        async function loadCompletedTournamentsForResults() { if (!db) return; elements.completedTournamentsTableBody.innerHTML = tableLoadingPlaceholderHtml(6); clearStatus(elements.tournamentResultsStatus); try { const tournamentsRef = query(ref(db, 'tournaments'), orderByChild('status')); const snapshot = await get(tournamentsRef); let tableHtml = ''; const completedOrResultTournaments = []; if (snapshot.exists()) { snapshot.forEach(childSnapshot => { const t = childSnapshot.val(); if (t && (t.status === 'completed' || t.status === 'result')) { completedOrResultTournaments.push({ id: childSnapshot.key, ...t }); } }); } completedOrResultTournaments.sort((a, b) => (b.startTime || 0) - (a.startTime || 0)); if (completedOrResultTournaments.length > 0) { completedOrResultTournaments.forEach(t => { const gameName = gameDataCache[t.gameId] || `<small class="text-warning" title="ID: ${t.gameId}">Unknown</small>`; const statusBadge = `<span class="status-badge text-bg-${t.status === 'result' ? 'primary' : 'success'}">${t.status}</span>`; const prizeDisplay = (t.prizePool > 0 ? `${formatCurrency(t.prizePool)}` : '') + ((t.prizePool > 0 && t.prizePoolCoins > 0) ? ' / ' : '') + (t.prizePoolCoins > 0 ? `<span class="text-coin">${formatCoins(t.prizePoolCoins)} <i class="bi bi-coin"></i></span>` : ''); tableHtml += `<tr> <td>${sanitizeHTML(t.name)}</td> <td>${gameName}</td> <td>${prizeDisplay || 'Participation'}</td> <td>${formatDate(t.startTime)}</td> <td>${statusBadge}</td> <td class="action-buttons"> <button class="btn btn-sm btn-info btn-manage-winners" data-id="${sanitizeHTML(t.id)}" data-name="${sanitizeHTML(t.name)}" title="Manage Winners"><i class="bi bi-award-fill"></i> Manage</button> </td> </tr>`; }); } elements.completedTournamentsTableBody.innerHTML = tableHtml || `<tr><td colspan="6" class="text-center p-3 text-muted">No completed tournaments found to manage results.</td></tr>`; } catch (error) { elements.completedTournamentsTableBody.innerHTML = `<tr><td colspan="6" class="text-center p-3 text-danger">Error: ${error.message}.</td></tr>`; showStatus(elements.tournamentResultsStatus, `Error loading completed tournaments: ${error.message}.`, "danger", false); } }
        async function openTournamentWinnerModal(tournamentId, tournamentName) { if (!db || !tournamentId) return; currentTournamentForResults = tournamentId; elements.winnerModalTournamentName.textContent = tournamentName; elements.winnerModalTournamentId.textContent = tournamentId; elements.tournamentWinnerPlayersTableBody.innerHTML = `<tr><td colspan="6" class="text-center p-3"><div class="spinner-border spinner-border-sm"></div> Loading players...</td></tr>`; clearStatus(elements.tournamentWinnerStatus); elements.tournamentResultNote.value = ''; getModalInstance(elements.tournamentWinnerModalEl)?.show(); try { const tournamentSnap = await get(ref(db, `tournaments/${tournamentId}`)); if (!tournamentSnap.exists()) { throw new Error("Tournament data not found."); } const tournamentData = tournamentSnap.val(); const registeredPlayers = tournamentData.registeredPlayers || {}; const winnersData = tournamentData.winners || {}; const playerIds = Object.keys(registeredPlayers); if (playerIds.length === 0) { elements.tournamentWinnerPlayersTableBody.innerHTML = `<tr><td colspan="6" class="text-center p-3 text-muted">No players were registered for this tournament.</td></tr>`; return; } let tableHtml = ''; let playerIndex = 0; const userFetchPromises = playerIds.map(uid => { return get(ref(db, `users/${uid}`)).then(userSnap => { if (userSnap.exists()) { return { uid, ...userSnap.val(), ...registeredPlayers[uid] }; } return { uid, displayName: 'Unknown User', email: 'N/A', ...registeredPlayers[uid] }; }).catch(() => ({ uid, displayName: 'Error Fetching User', email: 'N/A', ...registeredPlayers[uid] })); }); const detailedPlayers = await Promise.all(userFetchPromises); detailedPlayers.forEach(player => { playerIndex++; const existingWinnerInfo = winnersData[player.uid]; const isWinner = !!existingWinnerInfo; const winningAmount = isWinner ? existingWinnerInfo.amountWon : 0; const winningCoins = isWinner ? existingWinnerInfo.amountWonCoins : 0; tableHtml += ` <tr data-player-uid="${sanitizeHTML(player.uid)}"> <td>${playerIndex}</td> <td>${sanitizeHTML(player.displayName)} <small class="text-muted d-block">${sanitizeHTML(player.email)}</small></td> <td>${sanitizeHTML(player.gameUid || 'N/A')}</td> <td><input type="number" class="form-control form-control-sm winning-amount-pkr" value="${winningAmount}" min="0" step="any" ${isWinner ? 'disabled' : ''}></td> <td><input type="number" class="form-control form-control-sm winning-amount-coins" value="${winningCoins}" min="0" ${isWinner ? 'disabled' : ''}></td> <td class="player-winner-status"> ${isWinner ? `<span class="badge text-bg-success">Paid</span>` : `<span class="badge text-bg-secondary">Pending</span>`} </td> </tr>`; }); elements.tournamentWinnerPlayersTableBody.innerHTML = tableHtml; if (tournamentData.resultNote) elements.tournamentResultNote.value = tournamentData.resultNote; } catch (error) { elements.tournamentWinnerPlayersTableBody.innerHTML = `<tr><td colspan="6" class="text-center p-3 text-danger">Error loading players: ${error.message}</td></tr>`; showStatus(elements.tournamentWinnerStatus, `Error: ${error.message}`, "danger", false); } }
        async function distributeSelectedWinnings() { if (!db || !currentTournamentForResults || !currentAdminUser) return; const statusEl = elements.tournamentWinnerStatus; clearStatus(statusEl); showLoader(true); elements.distributeWinningsBtn.disabled = true; elements.finalizeTournamentResultsBtn.disabled = true; const updates = {}; const transactionPromises = []; let winnersProcessedCount = 0; const playerRows = elements.tournamentWinnerPlayersTableBody.querySelectorAll('tr[data-player-uid]'); if (playerRows.length === 0) { showStatus(statusEl, "No players found.", "info"); showLoader(false); return; } playerRows.forEach(row => { const userId = row.dataset.playerUid; const pkrInput = row.querySelector('.winning-amount-pkr'); const coinsInput = row.querySelector('.winning-amount-coins'); const playerStatusCell = row.querySelector('.player-winner-status'); if (pkrInput && coinsInput && !pkrInput.disabled) { const pkrAmount = parseFloat(pkrInput.value) || 0; const coinAmount = parseInt(coinsInput.value) || 0; if (pkrAmount > 0 || coinAmount > 0) { winnersProcessedCount++; transactionPromises.push( get(ref(db, `users/${userId}`)).then(userSnap => { if (userSnap.exists()) { const user = userSnap.val(); if(pkrAmount > 0) { updates[`users/${userId}/balance`] = (user.balance || 0) + pkrAmount; updates[`users/${userId}/winningCash`] = (user.winningCash || 0) + pkrAmount; } if(coinAmount > 0) { updates[`users/${userId}/gameCoins`] = (user.gameCoins || 0) + coinAmount; } if(pkrAmount > 0) updates[`transactions/${userId}/${push(ref(db)).key}`] = { type: 'tournament_winnings', amount: pkrAmount, timestamp: serverTimestamp(), description: `Winnings from: ${elements.winnerModalTournamentName.textContent}`, tournamentId: currentTournamentForResults, status: 'completed', adminUid: currentAdminUser.uid }; if(coinAmount > 0) updates[`coinTransactions/${userId}/${push(ref(db)).key}`] = { type: 'tournament_winnings_coins', amount: coinAmount, timestamp: serverTimestamp(), description: `Coin Winnings from: ${elements.winnerModalTournamentName.textContent}`, tournamentId: currentTournamentForResults, status: 'completed', adminUid: currentAdminUser.uid }; updates[`tournaments/${currentTournamentForResults}/winners/${userId}`] = { amountWon: pkrAmount, amountWonCoins: coinAmount, distributedAt: serverTimestamp(), adminUid: currentAdminUser.uid, gameUid: sanitizeHTML(row.cells[2].textContent) }; pkrInput.disabled = true; coinsInput.disabled = true; if(playerStatusCell) playerStatusCell.innerHTML = `<span class="badge text-bg-success">Paid</span>`; } else { console.warn(`User ${userId} not found.`); if(playerStatusCell) playerStatusCell.innerHTML = `<span class="badge text-bg-danger">User Error</span>`; } }) ); } } }); if (winnersProcessedCount === 0) { showStatus(statusEl, "No new winnings to distribute.", "info"); showLoader(false); elements.distributeWinningsBtn.disabled = false; elements.finalizeTournamentResultsBtn.disabled = false; return; } try { await Promise.all(transactionPromises); await update(ref(db), updates); showStatus(statusEl, `${winnersProcessedCount} winner(s) paid!`, "success", 4000); } catch (error) { console.error("Winnings dist error:", error); showStatus(statusEl, `Error: ${error.message}`, "danger", false); } finally { showLoader(false); elements.distributeWinningsBtn.disabled = false; elements.finalizeTournamentResultsBtn.disabled = false; } }
        async function finalizeTournamentResults() { if (!db || !currentTournamentForResults) return; if (!confirm("Finalize results? This marks tournament as 'result'.")) return; const statusEl = elements.tournamentWinnerStatus; clearStatus(statusEl); showLoader(true); elements.distributeWinningsBtn.disabled = true; elements.finalizeTournamentResultsBtn.disabled = true; const updates = {}; updates[`tournaments/${currentTournamentForResults}/status`] = 'result'; updates[`tournaments/${currentTournamentForResults}/resultNote`] = elements.tournamentResultNote.value.trim() || null; updates[`tournaments/${currentTournamentForResults}/resultFinalizedAt`] = serverTimestamp(); updates[`tournaments/${currentTournamentForResults}/resultFinalizedBy`] = currentAdminUser.uid; try { await update(ref(db), updates); showStatus(elements.tournamentResultsStatus, `Results finalized for ${elements.winnerModalTournamentName.textContent}.`, "success", 4000); getModalInstance(elements.tournamentWinnerModalEl)?.hide(); loadCompletedTournamentsForResults(); loadDashboardStats(); } catch (error) { console.error("Finalize error:", error); showStatus(statusEl, `Error: ${error.message}`, "danger", false); } finally { showLoader(false); elements.distributeWinningsBtn.disabled = false; elements.finalizeTournamentResultsBtn.disabled = false; currentTournamentForResults = null; } }

        async function saveHtmlGame() { if (!db) return; const gameId = elements.htmlGameEditId.value; const isEditing = !!gameId; const statusEl = elements.htmlGameStatus; clearStatus(statusEl); const gameData = { name: elements.htmlGameName.value.trim(), iconUrl: elements.htmlGameIconUrl.value.trim(), description: elements.htmlGameDescription.value.trim(), gameUrl: elements.htmlGameGameUrl.value.trim() || null, htmlContent: elements.htmlGameHtmlContent.value.trim() || null, costToPlayCoins: parseInt(elements.htmlGameCost.value) || 0, order: parseInt(elements.htmlGameOrder.value) || 0, enabled: elements.htmlGameEnabled.checked, updatedAt: serverTimestamp() }; if (!gameData.name || !gameData.iconUrl) { showStatus(statusEl, "Name and Icon URL are required.", "warning"); return; } if (!gameData.gameUrl && !gameData.htmlContent) { showStatus(statusEl, "Provide either a Game URL or HTML Content.", "warning"); return; } showLoader(true); elements.saveHtmlGameBtn.disabled = true; try { if (isEditing) { await update(ref(db, `htmlGames/${gameId}`), gameData); showStatus(elements.htmlGamesStatus, "HTML Game updated!", "success", 3000); } else { gameData.createdAt = serverTimestamp(); await set(push(ref(db, 'htmlGames')), gameData); showStatus(elements.htmlGamesStatus, "HTML Game added!", "success", 3000); } elements.htmlGameForm.reset(); getModalInstance(elements.htmlGameModalEl)?.hide(); loadHtmlGames(); } catch (error) { showStatus(statusEl, `Error: ${error.message}.`, "danger", false); } finally { showLoader(false); elements.saveHtmlGameBtn.disabled = false; } }
        async function openEditHtmlGameModal(gameId) { if (!db || !gameId) return; showLoader(true); elements.htmlGameForm.reset(); clearStatus(elements.htmlGameStatus); try { const snapshot = await get(ref(db, `htmlGames/${gameId}`)); if (!snapshot.exists()) throw new Error(`HTML Game ${gameId} not found.`); const game = snapshot.val(); elements.htmlGameModalTitle.textContent = "Edit HTML Game"; elements.htmlGameEditId.value = gameId; elements.htmlGameName.value = game.name || ''; elements.htmlGameIconUrl.value = game.iconUrl || ''; elements.htmlGameDescription.value = game.description || ''; elements.htmlGameGameUrl.value = game.gameUrl || ''; elements.htmlGameHtmlContent.value = game.htmlContent || ''; elements.htmlGameCost.value = game.costToPlayCoins || 0; elements.htmlGameOrder.value = game.order || 0; elements.htmlGameEnabled.checked = game.enabled === false ? false : true; getModalInstance(elements.htmlGameModalEl)?.show(); } catch (error) { showStatus(elements.htmlGamesStatus, `Error: ${error.message}`, "danger", false); } finally { showLoader(false); } }
        async function loadDiamondRequests(status) { if (!db) return; const targetTableBody = getElement(`${status}DiamondTableBody`); if (!targetTableBody) return; const q = query(ref(db, 'diamondRedemptionRequests'), orderByChild('status'), equalTo(status)); const listenerKey = `diamondRedemptionRequests-${status}`; const emptyColspan = status === 'pending_fulfillment' ? 6 : 7; targetTableBody.innerHTML = tableLoadingPlaceholderHtml(emptyColspan); clearStatus(elements.diamondRedemptionStatus); if (dbListeners[listenerKey]) try { off(q, 'value', dbListeners[listenerKey]); } catch(e){} dbListeners[listenerKey] = onValue(q, async (snapshot) => { let tableHtml = ''; if (snapshot.exists()) { const reqs = []; snapshot.forEach(child => reqs.push({ id: child.key, ...child.val() })); reqs.sort((a,b) => (b.requestTimestamp || 0) - (a.requestTimestamp || 0)); for(const req of reqs) { const user = userDataCache[req.userId] || (await get(ref(db, `users/${req.userId}`)).then(s => s.exists() ? s.val() : {displayName:'N/A',email:'N/A'})); const userDisplay = `${sanitizeHTML(user.displayName)} (<small class="text-muted">${sanitizeHTML(user.email)}</small>)`; let rowHtml = `<tr><td>${formatDate(req.requestTimestamp)}</td>`; if(status !== 'pending_fulfillment') rowHtml += `<td>${formatDate(req.processedAt)}</td>`; rowHtml += `<td>${userDisplay}</td><td>${sanitizeHTML(req.userGameUid)}</td><td>${formatCoins(req.diamondsRequested)}</td><td>${formatCoins(req.coinsSpent)}</td>`; if(status === 'pending_fulfillment') { rowHtml += `<td class="action-buttons"><button class="btn btn-sm btn-success btn-approve-diamond" data-id="${req.id}"><i class="bi bi-check-circle"></i> Approve</button> <button class="btn btn-sm btn-danger btn-reject-diamond" data-id="${req.id}"><i class="bi bi-x-circle"></i> Reject</button></td>`; } else if(status === 'fulfilled') { rowHtml += `<td><small>${sanitizeHTML(req.adminNote || 'Fulfilled')}</small></td>`; } else { rowHtml += `<td><small>${sanitizeHTML(req.rejectReason || 'Rejected')}</small></td>`; } rowHtml += `</tr>`; tableHtml += rowHtml; } } targetTableBody.innerHTML = tableHtml || `<tr><td colspan="${emptyColspan}" class="text-center p-3 text-muted">No ${status.replace('_', ' ')} requests.</td></tr>`; }, (error) => { targetTableBody.innerHTML = `<tr><td colspan="${emptyColspan}" class="text-danger p-3">Error: ${error.message}</td></tr>`; }); }
        async function openDiamondActionModal(reqId, type) { if (!db || !reqId || !type) return; showLoader(true); const reqRef = ref(db, `diamondRedemptionRequests/${reqId}`); currentDiamondAction = { id: reqId, type: type, userId: null, coinsSpent: 0 }; elements.diamondRejectReasonInput.value = ''; elements.diamondApproveNoteInput.value = ''; elements.diamondRejectReasonDiv.style.display = 'none'; elements.diamondApproveNoteDiv.style.display = 'none'; clearStatus(elements.diamondActionStatus); elements.approveDiamondBtn.style.display = 'inline-block'; elements.rejectDiamondBtn.style.display = 'inline-block'; try { const snapshot = await get(reqRef); if (!snapshot.exists()) throw new Error(`Request ${reqId} not found.`); const req = snapshot.val(); if (req.status !== 'pending_fulfillment') { alert(`Request already processed (Status: ${req.status}).`); showLoader(false); return; } currentDiamondAction.userId = req.userId; currentDiamondAction.coinsSpent = Number(req.coinsSpent || 0); const user = userDataCache[req.userId] || (await get(ref(db, `users/${req.userId}`)).then(s => s.exists() ? s.val() : {displayName:'N/A',email:'N/A'})); elements.diamondDetailId.textContent = reqId; elements.diamondDetailUser.textContent = `${user.displayName} (${user.email})`; elements.diamondDetailUserUid.textContent = req.userId; elements.diamondDetailGameUid.textContent = req.userGameUid; elements.diamondDetailAmount.textContent = req.diamondsRequested; elements.diamondDetailCoinsSpent.textContent = req.coinsSpent; if (type === 'reject') { elements.diamondRejectReasonDiv.style.display = 'block'; elements.approveDiamondBtn.style.display = 'none'; } else { elements.diamondApproveNoteDiv.style.display = 'block'; elements.rejectDiamondBtn.style.display = 'none'; } getModalInstance(elements.diamondActionModalEl)?.show(); } catch (error) { showStatus(elements.diamondRedemptionStatus, `Error: ${error.message}`, 'danger'); } finally { showLoader(false); } }
        async function processDiamondAction() { if (!db || !currentDiamondAction.id || !currentDiamondAction.type || !currentDiamondAction.userId) return; const { id, type, userId, coinsSpent } = currentDiamondAction; const statusEl = elements.diamondActionStatus; clearStatus(statusEl); showLoader(true); const updates = {}; const reqRefPath = `diamondRedemptionRequests/${id}`; try { if (type === 'reject') { const reason = elements.diamondRejectReasonInput.value.trim(); if (!reason) throw new Error("Rejection reason required."); updates[`${reqRefPath}/status`] = 'rejected'; updates[`${reqRefPath}/rejectReason`] = reason; updates[`${reqRefPath}/processedAt`] = serverTimestamp(); updates[`${reqRefPath}/processedBy`] = currentAdminUser.uid; await runTransaction(ref(db, `users/${userId}`), (profile) => { if (profile) profile.gameCoins = (profile.gameCoins || 0) + coinsSpent; return profile; }); await set(push(ref(db, `coinTransactions/${userId}`)), { type: 'redeem_failed_refund', amount: coinsSpent, timestamp: serverTimestamp(), description: `Refund Rejected Redemption: ${id}`, status: 'completed', adminUid: currentAdminUser.uid }); } else { const adminNote = elements.diamondApproveNoteInput.value.trim(); updates[`${reqRefPath}/status`] = 'fulfilled'; updates[`${reqRefPath}/adminNote`] = adminNote || 'Fulfilled by Admin'; updates[`${reqRefPath}/processedAt`] = serverTimestamp(); updates[`${reqRefPath}/processedBy`] = currentAdminUser.uid; } await update(ref(db), updates); showStatus(elements.diamondRedemptionStatus, `Request ${type === 'reject' ? 'rejected' : 'fulfilled'}!`, 'success', 3000); getModalInstance(elements.diamondActionModalEl)?.hide(); } catch (error) { showStatus(statusEl, `Error: ${error.message}`, "danger"); } finally { showLoader(false); } }
        async function loadDiamondTiers() { if (!db) return; const tiersRef = ref(db, 'settings/gameCoinOptions/diamondRedemptionTiers'); elements.diamondTiersTableBody.innerHTML = tableLoadingPlaceholderHtml(6); clearStatus(elements.diamondTiersStatus); try { const snapshot = await get(tiersRef); let tableHtml = ''; if (snapshot.exists()) { snapshot.forEach(childSnapshot => { const tierId = childSnapshot.key; const tier = childSnapshot.val(); if (tier && tier.title) { tableHtml += `<tr><td>${sanitizeHTML(tier.title)}</td><td>${formatCoins(tier.diamonds)}</td><td>${formatCoins(tier.cost)}</td><td><span class="status-badge text-bg-${tier.oneTime ? 'warning' : 'secondary'}">${tier.oneTime ? 'Yes' : 'No'}</span></td><td><span class="status-badge text-bg-${tier.enabled ? 'success' : 'secondary'}">${tier.enabled ? 'Yes' : 'No'}</span></td><td class="action-buttons"><button class="btn btn-sm btn-info btn-edit-tier" data-id="${tierId}"><i class="bi bi-pencil-square"></i></button><button class="btn btn-sm btn-danger btn-delete-tier" data-id="${tierId}"><i class="bi bi-trash"></i></button></td></tr>`; } }); } elements.diamondTiersTableBody.innerHTML = tableHtml || `<tr><td colspan="6" class="text-center p-3 text-muted">No diamond tiers found.</td></tr>`; } catch (error) { showStatus(elements.diamondTiersStatus, `Error loading tiers: ${error.message}`, 'danger'); } }
        async function saveDiamondTier() { if (!db) return; const tierId = elements.diamondTierEditId.value; const isEditing = !!tierId; const statusEl = elements.diamondTierStatus; clearStatus(statusEl); const tierData = { title: elements.tierTitle.value.trim(), description: elements.tierDescription.value.trim(), diamonds: parseInt(elements.tierDiamonds.value) || 0, cost: parseInt(elements.tierCost.value) || 0, oneTime: elements.tierOneTime.checked, enabled: elements.tierEnabled.checked }; if (!tierData.title || tierData.diamonds <= 0) { showStatus(statusEl, "Title and a valid diamond amount are required.", "warning"); return; } showLoader(true); const path = isEditing ? tierId : push(ref(db, 'settings/gameCoinOptions/diamondRedemptionTiers')).key; try { await set(ref(db, `settings/gameCoinOptions/diamondRedemptionTiers/${path}`), tierData); showStatus(elements.diamondTiersStatus, `Tier ${isEditing ? 'updated' : 'added'}!`, "success", 3000); getModalInstance(elements.diamondTierModalEl)?.hide(); loadDiamondTiers(); } catch (error) { showStatus(statusEl, `Error: ${error.message}`, "danger"); } finally { showLoader(false); } }
        async function openEditDiamondTierModal(tierId) { if (!db || !tierId) return; showLoader(true); elements.diamondTierForm.reset(); clearStatus(elements.diamondTierStatus); try { const snapshot = await get(ref(db, `settings/gameCoinOptions/diamondRedemptionTiers/${tierId}`)); if (!snapshot.exists()) throw new Error("Tier not found."); const tier = snapshot.val(); elements.diamondTierModalTitle.textContent = "Edit Tier"; elements.diamondTierEditId.value = tierId; elements.tierTitle.value = tier.title || ''; elements.tierDescription.value = tier.description || ''; elements.tierDiamonds.value = tier.diamonds || 0; elements.tierCost.value = tier.cost || 0; elements.tierOneTime.checked = tier.oneTime || false; elements.tierEnabled.checked = tier.enabled === false ? false : true; getModalInstance(elements.diamondTierModalEl)?.show(); } catch (error) { showStatus(elements.diamondTiersStatus, `Error: ${error.message}`, 'danger'); } finally { showLoader(false); } }
        async function deleteDiamondTier(tierId) { if (!db || !tierId || !confirm("Delete this diamond tier?")) return; showLoader(true); try { await remove(ref(db, `settings/gameCoinOptions/diamondRedemptionTiers/${tierId}`)); showStatus(elements.diamondTiersStatus, "Tier deleted.", "success", 3000); loadDiamondTiers(); } catch (error) { showStatus(elements.diamondTiersStatus, `Error: ${error.message}`, 'danger'); } finally { showLoader(false); } }
        async function loadTasks() { if (!db) return; const tasksRef = ref(db, 'settings/tasks'); elements.tasksTableBody.innerHTML = tableLoadingPlaceholderHtml(6); clearStatus(elements.tasksStatus); try { const snapshot = await get(tasksRef); let tableHtml = ''; if (snapshot.exists()) { snapshot.forEach(childSnapshot => { const taskId = childSnapshot.key; const task = childSnapshot.val(); if (task && task.title) { tableHtml += `<tr><td>${sanitizeHTML(task.title)}</td><td>${formatCoins(task.rewardCoins)}</td><td>${sanitizeHTML(task.type)}</td><td>${formatCoins(task.goal)}</td><td><span class="status-badge text-bg-${task.enabled ? 'success' : 'secondary'}">${task.enabled ? 'Yes' : 'No'}</span></td><td class="action-buttons"><button class="btn btn-sm btn-info btn-edit-task" data-id="${taskId}"><i class="bi bi-pencil-square"></i></button><button class="btn btn-sm btn-danger btn-delete-task" data-id="${taskId}"><i class="bi bi-trash"></i></button></td></tr>`; } }); } elements.tasksTableBody.innerHTML = tableHtml || `<tr><td colspan="6" class="text-center p-3 text-muted">No daily tasks found.</td></tr>`; } catch (error) { showStatus(elements.tasksStatus, `Error loading tasks: ${error.message}`, 'danger'); } }
        async function saveTask() { if (!db) return; const taskId = elements.taskEditId.value; const isEditing = !!taskId; const statusEl = elements.taskStatus; clearStatus(statusEl); const taskData = { title: elements.taskTitle.value.trim(), description: elements.taskDescription.value.trim(), rewardCoins: parseInt(elements.taskReward.value) || 0, type: elements.taskType.value, goal: parseInt(elements.taskGoal.value) || 0, enabled: elements.taskEnabled.checked }; if (!taskData.title || taskData.rewardCoins <= 0 || taskData.goal <= 0) { showStatus(statusEl, "Title, a valid reward, and goal are required.", "warning"); return; } showLoader(true); const path = isEditing ? taskId : push(ref(db, 'settings/tasks')).key; try { await set(ref(db, `settings/tasks/${path}`), taskData); showStatus(elements.tasksStatus, `Task ${isEditing ? 'updated' : 'added'}!`, "success", 3000); getModalInstance(elements.taskModalEl)?.hide(); loadTasks(); } catch (error) { showStatus(statusEl, `Error: ${error.message}`, "danger"); } finally { showLoader(false); } }
        async function openEditTaskModal(taskId) { if (!db || !taskId) return; showLoader(true); elements.taskForm.reset(); clearStatus(elements.taskStatus); try { const snapshot = await get(ref(db, `settings/tasks/${taskId}`)); if (!snapshot.exists()) throw new Error("Task not found."); const task = snapshot.val(); elements.taskModalTitle.textContent = "Edit Task"; elements.taskEditId.value = taskId; elements.taskTitle.value = task.title || ''; elements.taskDescription.value = task.description || ''; elements.taskReward.value = task.rewardCoins || 0; elements.taskType.value = task.type || 'play_duration'; elements.taskGoal.value = task.goal || 0; elements.taskEnabled.checked = task.enabled === false ? false : true; getModalInstance(elements.taskModalEl)?.show(); } catch (error) { showStatus(elements.tasksStatus, `Error: ${error.message}`, 'danger'); } finally { showLoader(false); } }
        async function deleteTask(taskId) { if (!db || !taskId || !confirm("Delete this task?")) return; showLoader(true); try { await remove(ref(db, `settings/tasks/${taskId}`)); showStatus(elements.tasksStatus, "Task deleted.", "success", 3000); loadTasks(); } catch (error) { showStatus(elements.tasksStatus, `Error: ${error.message}`, 'danger'); } finally { showLoader(false); } }


        function initializeAdminEventListeners() {
            console.log("Initializing Admin Event Listeners...");
            if (!auth || !db) { console.error("Cannot init event listeners, Firebase not ready."); return; }

            elements.adminSetupForm?.addEventListener('submit', setupAdmin);
            elements.adminLoginForm?.addEventListener('submit', loginAdmin);
            elements.adminLogoutBtn?.addEventListener('click', logoutAdminUser);

            elements.sidebarLinks?.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const sectionId = link.dataset.section;
                    if (sectionId) {
                        showAdminSection(sectionId);
                    }
                });
            });

            elements.saveGameBtn?.addEventListener('click', saveGame);
            elements.saveHtmlGameBtn?.addEventListener('click', saveHtmlGame);
            elements.savePromotionBtn?.addEventListener('click', savePromotion);
            elements.saveTournamentBtn?.addEventListener('click', saveTournament);
            elements.saveNewUserBtn?.addEventListener('click', saveNewUser);
            elements.appSettingsForm?.addEventListener('submit', saveSettings);
            elements.updateBalanceForm?.addEventListener('submit', updateUserBalance);
            elements.saveDiamondTierBtn?.addEventListener('click', saveDiamondTier);
            elements.saveTaskBtn?.addEventListener('click', saveTask);
            elements.addNewGameBtn?.addEventListener('click', () => { elements.gameForm?.reset(); elements.gameEditId.value = ''; elements.gameModalTitle.textContent = "Add New Esport Game"; clearStatus(elements.gameStatus); const imgbbEl = elements.gameForm?.querySelector('.imgbb-upload-status'); if(imgbbEl){ imgbbEl.textContent=''; imgbbEl.style.display='none';} });
            elements.addNewHtmlGameBtn?.addEventListener('click', () => { elements.htmlGameForm?.reset(); elements.htmlGameEditId.value = ''; elements.htmlGameModalTitle.textContent = "Add New HTML Game"; clearStatus(elements.htmlGameStatus); });
            elements.addNewPromotionBtn?.addEventListener('click', () => { elements.promotionForm?.reset(); elements.promotionEditId.value = ''; elements.promotionModalTitle.textContent = "Add New Promotion"; clearStatus(elements.promotionStatus); const imgbbEl = elements.promotionForm?.querySelector('.imgbb-upload-status'); if(imgbbEl){ imgbbEl.textContent=''; imgbbEl.style.display='none';} });
            elements.addNewTournamentBtn?.addEventListener('click', () => { currentEditingTournamentId = null; elements.tournamentForm?.reset(); if(elements.tournamentModalTitle) elements.tournamentModalTitle.textContent = "Add New Tournament"; clearStatus(elements.addTournamentStatus); populateGameSelect(); });
            getElement('addNewDiamondTierBtn')?.addEventListener('click', () => { elements.diamondTierForm?.reset(); elements.diamondTierEditId.value = ''; elements.diamondTierModalTitle.textContent = "Add New Tier"; clearStatus(elements.diamondTierStatus); });
            getElement('addNewTaskBtn')?.addEventListener('click', () => { elements.taskForm?.reset(); elements.taskEditId.value = ''; elements.taskModalTitle.textContent = "Add New Task"; clearStatus(elements.taskStatus); });
            elements.userBlockBtn?.addEventListener('click', toggleUserBlock);
            elements.userDeleteBtn?.addEventListener('click', (e) => { const userId = e.target.closest('button')?.dataset.id; if (userId) deleteUser(userId); });
            elements.approveWithdrawalBtn?.addEventListener('click', processWithdrawalAction);
            elements.rejectWithdrawalBtn?.addEventListener('click', processWithdrawalAction);
            elements.approveDepositBtn?.addEventListener('click', processDepositAction);
            elements.rejectDepositBtn?.addEventListener('click', processDepositAction);
            elements.approveDiamondBtn?.addEventListener('click', () => processDiamondAction());
            elements.rejectDiamondBtn?.addEventListener('click', () => processDiamondAction());
            elements.addDemoDataBtn?.addEventListener('click', addDemoData);
            elements.userSearchInput?.addEventListener('input', filterUsers);
            elements.fetchUserTransactionsBtn?.addEventListener('click', fetchUserTransactions);
            elements.distributeWinningsBtn?.addEventListener('click', distributeSelectedWinnings);
            elements.finalizeTournamentResultsBtn?.addEventListener('click', finalizeTournamentResults);


            document.body.addEventListener('click', (event) => {
                const target = event.target;
                const actionButton = target.closest('button[data-id], button[data-req-key]');
                const copyIcon = target.closest('.copy-btn[data-target-text]');

                if (actionButton) {
                    const targetId = actionButton.dataset.id;
                    const reqKey = actionButton.dataset.reqKey;
                    if (actionButton.classList.contains('btn-delete-game') && targetId) deleteGame(targetId);
                    else if (actionButton.classList.contains('btn-edit-game') && targetId) openEditGameModal(targetId);
                    else if (actionButton.classList.contains('btn-delete-html-game') && targetId) deleteHtmlGame(targetId);
                    else if (actionButton.classList.contains('btn-edit-html-game') && targetId) openEditHtmlGameModal(targetId);
                    else if (actionButton.classList.contains('btn-delete-promo') && targetId) deletePromotion(targetId);
                    else if (actionButton.classList.contains('btn-edit-promo') && targetId) openEditPromotionModal(targetId);
                    else if (actionButton.classList.contains('btn-delete-tournament') && targetId) deleteTournament(targetId);
                    else if (actionButton.classList.contains('btn-edit-tournament') && targetId) openEditTournamentModal(targetId);
                    else if (actionButton.classList.contains('btn-delete-tier') && targetId) deleteDiamondTier(targetId);
                    else if (actionButton.classList.contains('btn-edit-tier') && targetId) openEditDiamondTierModal(targetId);
                    else if (actionButton.classList.contains('btn-delete-task') && targetId) deleteTask(targetId);
                    else if (actionButton.classList.contains('btn-edit-task') && targetId) openEditTaskModal(targetId);
                    else if (actionButton.classList.contains('btn-view-user') && targetId) openUserModal(targetId);
                    else if (actionButton.classList.contains('btn-approve-withdrawal') && targetId) openWithdrawalActionModal(targetId, 'approve');
                    else if (actionButton.classList.contains('btn-reject-withdrawal') && targetId) openWithdrawalActionModal(targetId, 'reject');
                    else if (actionButton.classList.contains('btn-approve-diamond') && targetId) openDiamondActionModal(targetId, 'approve');
                    else if (actionButton.classList.contains('btn-reject-diamond') && targetId) openDiamondActionModal(targetId, 'reject');
                    else if (actionButton.classList.contains('btn-delete-user') && targetId) deleteUser(targetId);
                    else if (actionButton.classList.contains('btn-view-registered') && targetId) openRegisteredPlayersModal(targetId, actionButton.dataset.name);
                    else if (actionButton.classList.contains('btn-approve-deposit') && reqKey) openDepositActionModal(reqKey, 'approve');
                    else if (actionButton.classList.contains('btn-reject-deposit') && reqKey) openDepositActionModal(reqKey, 'reject');
                    else if (actionButton.classList.contains('btn-manage-winners') && targetId) openTournamentWinnerModal(targetId, actionButton.dataset.name);
                    return;
                }
                if (copyIcon) {
                    const textToCopy = copyIcon.dataset.targetText;
                    if(textToCopy) copyToClipboard(textToCopy);
                    return;
                }
            });

            const resetModal = (modalEl, formEl, statusEl, idField = null, titleEl = null, defaultTitle = 'Add New Item', imgbbSel = '.imgbb-upload-status') => {
                modalEl?.addEventListener('hidden.bs.modal', () => {
                    formEl?.reset();
                    if(statusEl) clearStatus(statusEl);
                    const imgbbStat = formEl?.querySelector(imgbbSel);
                    if(imgbbStat) { imgbbStat.textContent=''; imgbbStat.style.display='none'; }
                    if (idField) idField.value = '';
                    if (titleEl) titleEl.textContent = defaultTitle;
                    if (modalEl === elements.addTournamentModalEl) currentEditingTournamentId = null;
                    if (modalEl === elements.userModalEl) elements.editUserUid.value = '';
                    if (modalEl === elements.withdrawalActionModalEl) currentWithdrawalAction = { id: null, type: null, userId: null, amount:0 };
                    if (modalEl === elements.depositActionModalEl) currentDepositAction = { id: null, type: null, userId: null, amount: 0, requestKey: null };
                    if (modalEl === elements.diamondActionModalEl) currentDiamondAction = { id: null, type: null, userId: null, coinsSpent: 0 };
                    if (modalEl === elements.tournamentWinnerModalEl) currentTournamentForResults = null;
                    currentEditingItemId = null;
                });
            };
            resetModal(elements.gameModalEl, elements.gameForm, elements.gameStatus, elements.gameEditId, elements.gameModalTitle, 'Add New Esport Game');
            resetModal(elements.htmlGameModalEl, elements.htmlGameForm, elements.htmlGameStatus, elements.htmlGameEditId, elements.htmlGameModalTitle, 'Add New HTML Game');
            resetModal(elements.promotionModalEl, elements.promotionForm, elements.promotionStatus, elements.promotionEditId, elements.promotionModalTitle, 'Add New Promotion');
            resetModal(elements.addTournamentModalEl, elements.tournamentForm, elements.addTournamentStatus, elements.tournamentEditId, elements.tournamentModalTitle, 'Add New Tournament', null);
            resetModal(elements.addUserModalEl, elements.addUserForm, elements.addUserStatus, null, null, '', null);
            resetModal(elements.userModalEl, elements.updateBalanceForm, elements.balanceUpdateStatus, elements.editUserUid, null, '', null);
            resetModal(elements.withdrawalActionModalEl, null, elements.withdrawalActionStatus, null, null, '', null);
            resetModal(elements.diamondActionModalEl, null, elements.diamondActionStatus, null, null, '', null);
            resetModal(elements.depositActionModalEl, null, elements.depositActionStatus, null, null, '', null);
            resetModal(elements.registeredPlayersModalEl, null, elements.registeredPlayersStatus, null, null, '', null);
            resetModal(elements.tournamentWinnerModalEl, elements.tournamentWinnerForm, elements.tournamentWinnerStatus, null, elements.tournamentWinnerModalTitle, 'Distribute Winnings', null);
            resetModal(elements.diamondTierModalEl, elements.diamondTierForm, elements.diamondTierStatus, elements.diamondTierEditId, elements.diamondTierModalTitle, 'Add New Tier');
            resetModal(elements.taskModalEl, elements.taskForm, elements.taskStatus, elements.taskEditId, elements.taskModalTitle, 'Add New Task');

        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("Admin Panel DOM Loaded.");
            if (!app || !auth || !db) {
                console.error("DOM loaded, but Firebase services not initialized. Check Firebase config and initialization block.");
                return;
            }
            initializeAdminEventListeners();
            onAuthStateChanged(auth, handleAdminAuthStateChange);
            handleInitialLoad();
        });
    </script>

</body>
</html>
```
